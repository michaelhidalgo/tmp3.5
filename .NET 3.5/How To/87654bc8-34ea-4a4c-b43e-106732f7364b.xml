<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="830982668" Content_Hash="1403788136">
  <Metadata>
    <Id>87654bc8-34ea-4a4c-b43e-106732f7364b</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>HTTP レスポンス分割バグをテストする方法</Title>
    <Category>ネットワーキング</Category>
    <Phase>テスト</Phase>
    <Technology>Web アプリケーション</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>Andres De Vivanco</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<P><P><SPAN></SPAN></P><H1><SPAN>適用対象は次のとおりです。</SPAN></H1><P></P><UL><LI><SPAN>ASP.NET、Java、PHP などの Web 開発プラットフォームで 開発された Web アプリケーションとサービス。<B></B></SPAN></LI></UL><P><B><SPAN>&nbsp;</SPAN></B></P><H1><SPAN>概要</SPAN></H1><P><SPAN>HTTP レスポンス分割バグは比較的新しい脆弱性クラスで、攻撃者は脆弱な Web サーバーのレスポンスを分割して追加のレスポンスを追加することにより、制御することができます。<SPAN>&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>攻撃者は追加のレスポンスを使用して、ウェブサイト改ざん、Web キャッシュ ポイズニング、クロスサイト スクリプティング (XSS) など、さまざまなタイプの攻撃を実行します。<SPAN>&nbsp; </SPAN></SPAN></P><P><SPAN>HTTP レスポンス分割の脆弱性では、 攻撃者、脆弱な Web サーバー、およびターゲットの3 者が関与します。<SPAN>&nbsp; </SPAN>攻撃者は脆弱なサーバーを使用してターゲットで攻撃を実行します。<SPAN>&nbsp; </SPAN>ターゲットは一般的にインターネット ブラウザ クライアント (XSS およびウェブサイト改ざんの場合) またはキャッシュ サーバー (キャッシュ ポイズニングの場合) です。</SPAN></P><P><SPAN>これらの手順に従って、HTTP レスポンス分割バグをテストします:</SPAN></P><UL><LI><SPAN>手順 1: <SPAN> </SPAN>攻撃のシナリオを理解する</SPAN><LI><SPAN>手順 2: <SPAN> </SPAN>原因と対応策を分析する</SPAN><LI><SPAN>手順 3: <SPAN> </SPAN>テストと調査を開始する</SPAN><LI><SPAN>手順 4: <SPAN> </SPAN>テスト ケースを微調整する</SPAN></LI></UL><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>手順 1: <SPAN> </SPAN>攻撃のシナリオを理解する</SPAN></H1><P><SPAN>HTTP レスポンス分割の脆弱性をテストする最初の手順は、攻撃シナリオを理解することです。<SPAN>&nbsp; </SPAN>HTTP レスポンス分割攻撃を実行する一般的なシナリオは 2 つあります:</SPAN></P><UL><LI><SPAN>リダイレクトを使用した HTTP レスポンス分割。</SPAN><LI><SPAN>ヘッダの構築を悪用することによる HTTP レスポンス分割。</SPAN></LI></UL><P><SPAN>さらに、HTTP レスポンス分割の脆弱性は以下のすべてのペイロードで使用することができます:</SPAN></P><UL><LI><SPAN>ウェブサイト改ざん</SPAN><LI><SPAN>クロスサイト スクリプティング (XSS)</SPAN><LI><SPAN>Web キャッシュ ポイズニング</SPAN><LI><SPAN>ページ ハイジャック</SPAN></LI></UL><P><SPAN></SPAN>&nbsp;</P><H2><SPAN><EM>シナリオ 1: リダイレクトを使用した HTTP レスポンス分割</EM></SPAN></H2><P><SPAN>最初の最も一般的なレスポンス分割攻撃は、インターネット クライアントのブラウザをターゲットにし、リダイレクトを使用して攻撃を遂行します。<SPAN>&nbsp; </SPAN>このシナリオを理解するには、リダイレクトが機能する方法を理解する必要があります。<SPAN>&nbsp;&nbsp; </SPAN>単純な PHP リダイレクト ページ (redirect.php) は次の [] のように表示されます:</SPAN></P><pre><SPAN><BR>&lt;?php<BR>   &nbsp;header ("Location: " . $_GET['page']);<BR>?&gt;<BR></SPAN></pre><P><SPAN>以下のリンクはインターネット ブラウザ クライアントを www.yahoo.com にリダイレクトします:</SPAN></P><pre><SPAN>http://vulnsite.com/redirect.php?page=http://www.yahoo.com</SPAN></pre><P><SPAN></SPAN></P><P><SPAN>クライアントが上記のリンクをクリックすると、ブラウザは以下のリクエストをサーバーに送信します:</SPAN><SPAN>&nbsp;</SPAN></P><pre><SPAN>GET <A href="http://vulnsite.com/redirect.php?page=http://www.yahoo.com">http://vulnsite.com/redirect.php?page=http://www.yahoo.com</A> HTTP/1.1<BR>Host: vulnsite.com<BR>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<BR>Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<BR>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<BR>Accept-Encoding: gzip,deflate<BR>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<BR>Keep-Alive: 300<BR>Proxy-Connection: keep-alive</SPAN><SPAN>&nbsp;</SPAN></pre><P><SPAN>サーバーのリダイレクトでは、リソースが移動されたことをクライアントに示す以下のパケットで応答します:</SPAN></P><P><SPAN></SPAN></P><pre><SPAN>HTTP/1.1 302 Found<BR>Date: Tue, 13 May 2008 20:22:28 GMT<BR>Server: Apache/2.2.6 (Win32) PHP/5.2.5<BR>X-Powered-By: PHP/5.2.5<BR>Location: <STRONG>http://www.yahoo.com</STRONG></SPAN></pre><P><SPAN></SPAN></P><P><SPAN>その後、クライアントは Location ヘッダによって指定されたアドレスにリクエストを送信します:</SPAN></P><pre><SPAN>GET <STRONG>http://www.yahoo.com</STRONG>:80/ HTTP/1.1<BR>Host: www.yahoo.com<BR>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<BR>Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<BR>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<BR>Accept-Encoding: gzip,deflate<BR>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<BR></SPAN></pre><P><SPAN></SPAN></P><P><SPAN>HTTP レスポンス分割攻撃で、攻撃者は追加のレスポンスの起点となる悪意のあるリンクを送信します:</SPAN></P><pre><SPAN>http://vulnsite.com/redirect.php?page=<SPAN><STRONG>abc%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a&lt;html&gt;&lt;font%20color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</STRONG></SPAN></SPAN></pre><P><SPAN></SPAN></P><P><SPAN>挿入されたデータは次のように書き込むこともできます:</SPAN></P><pre><SPAN><STRONG>abc\r\n<BR>Content-Type: text/html\r\n<BR>\r\n<BR>HTTP/1.1 200 OK\r\n<BR>Content-Type: text/html\r\n<BR>\r\n<BR>&lt;html&gt;&lt;font color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;<BR></STRONG></SPAN></pre><P><SPAN></SPAN></P><P><SPAN>これで、クライアントが上記の悪意のあるリンクをクリックすると、ブラウザは以下のリクエストをサーバーに送信します:</SPAN></P><P><SPAN></SPAN></P><pre><SPAN>GET http://vulnsite.com/redirect.php?page=<STRONG>abc%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a&lt;html&gt;&lt;font%20color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</STRONG><BR>Host: vulnsite.com<BR>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<BR>Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<BR>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<BR>Accept-Encoding: gzip,deflate<BR>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<BR>Keep-Alive: 300<BR>Proxy-Connection: keep-alive</SPAN></pre><P><SPAN></SPAN></P><P><SPAN>サーバーは 1 つのパケットではなく、以下の 2 つのパケットで応答します。<SPAN>&nbsp; </SPAN>サーバーがこのように応答するのは、二重の </SPAN><SPAN>CR/LF</SPAN><SPAN> を </SPAN><SPAN>Content</SPAN><SPAN>-</SPAN><SPAN>Length</SPAN><SPAN> の後に別々のパケットで解析するためです:</SPAN><SPAN>&nbsp;</SPAN></P><pre><SPAN>HTTP/1.1 302 Found<BR>Date: Tue, 13 May 2008 20:22:28 GMT<BR>Server: Apache/2.2.6 (Win32) PHP/5.2.5<BR>X-Powered-By: PHP/5.2.5<BR>Location: <STRONG>abc<BR>Content-Length: 0<BR>&nbsp;<BR>HTTP/1.1 200 OK</STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (separate packet)<BR><STRONG>Content-Type: text/html<BR>Content-Length: 47</STRONG></SPAN></pre><pre><SPAN><STRONG>&lt;html&gt;&lt;font color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</STRONG></SPAN><SPAN></SPAN></pre><P><SPAN></SPAN></P><P><SPAN>&nbsp;</SPAN><SPAN>これで、ターゲット ブラウザは次のようなページを表示します:</SPAN></P><P><SPAN></SPAN></P><P><SPAN>Attacked!!!</SPAN></P><P><SPAN></SPAN></P><P><SPAN>攻撃者は、改ざんを行う際に、銀行口座のフィッシングや、被害者のセッション cookie を攻撃者のサイトに送信するクロスサイト スクリプティングのスクリプトなど、より複雑なページを選択して使用することができます。</SPAN><SPAN>&nbsp;</SPAN></P><P><SPAN>&nbsp;</SPAN></P><H2><EM><SPAN>シナリオ 2: </SPAN><SPAN>ヘッダの構成を悪用することによる HTTP レスポンス分割</SPAN></EM></H2><P><SPAN>このシナリオでは、攻撃者はリダイレクト ページを必要としません。<SPAN>&nbsp;&nbsp; </SPAN>多数のアプリケーションは、 URL パラメータなどの 一時ストアやデータベースなどの永続的なストアからデータを読み込むことによって、</SPAN><SPAN>Set-Cookie</SPAN><SPAN> や </SPAN><SPAN>Location</SPAN><SPAN> などのレスポンス ヘッダを構築します。<SPAN>&nbsp;&nbsp; </SPAN>たとえば、以下の Java コードはデータベースから ID 値を読み込むことによって cookie を設定します:</SPAN></P><pre><BR>SqlCommand sqlComm = new SqlCommand("SELECT userid FROM users WHERE username LIKE " + Request.QueryString["user"], sqlConn);</pre><pre>SqlDataReader sqlReader = sqlComm.ExecuteReader();</pre><pre>string userid = sqlReader.GetString("userid");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>Cookie cookie = new Cookie("ID", userid);<BR>response.addCookie(cookie);<BR><SPAN>&nbsp;</SPAN></pre><P><SPAN>ユーザー ID が </SPAN><SPAN>10-300-565</SPAN><SPAN> などの通常の値である場合、サーバーはユーザーに単一のレスポンスを送信します。</SPAN></P><pre><SPAN>HTTP/1.1 200 OK<BR>...<BR>Set-Cookie: id=10-300-565<BR>...<BR></SPAN></pre><pre><SPAN></SPAN></pre><P><SPAN>ただし、攻撃者は二重の</SPAN><SPAN> CR/LF </SPAN><SPAN>をデータベース レコードに追加することによって、追加のレスポンスを送信するようにサーバーを強制することができます</SPAN><SPAN>:</SPAN><SPAN></SPAN></P><P><SPAN></SPAN></P><pre><SPAN>10-300-5650<SPAN><STRONG>d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a&lt;html&gt;&lt;font%20color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</STRONG></SPAN></SPAN></pre><P><SPAN>サーバーを強制して次のように応答するようにします:</SPAN><SPAN>&nbsp;</SPAN></P><pre><SPAN>HTTP/1.1 200 OK<BR>...<BR>Set-Cookie: id=<STRONG>10-300-565<BR>Content-Length: 0<BR>&nbsp;<BR>HTTP/1.1 200 OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>(separate packet)<BR><STRONG>Content-Type: text/html<BR>Content-Length: 47<BR>&nbsp;<BR>&lt;html&gt;&lt;font color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;<BR></STRONG>&nbsp;</SPAN></pre><H2><SPAN><EM>ペイロード 1:&nbsp;<SPAN> </SPAN>フィッシング</EM></SPAN></H2><P><SPAN>このペイロードは前の 2 つのシナリオで見られますが、被害者に追加のページを送信します。<SPAN>&nbsp; </SPAN>目的は、被害者を騙して 2 番目のレスポンスが合法的でオリジナルのサイトを安全に閲覧することができると信じさせることです。<SPAN>&nbsp; </SPAN>攻撃者は、その後、ユーザー名とパスワードや、銀行口座と PIN 番号を取り込む特定のフィッシング目的で 2 番目のレスポンスを変更します。<SPAN>&nbsp; </SPAN>ターゲットのブラウザは 2 番目のレスポンスを解析し、このレスポンスは Web クライアントに正規サーバーから送信されてきたかのように表示されます。<SPAN>&nbsp; </SPAN>このペイロードに使用された攻撃データは 2 番目のページを表示します (上記に表示):</SPAN></P><pre><STRONG><SPAN>0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a&lt;html&gt;&lt;font%20color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</SPAN></STRONG>&nbsp;</pre><H2><SPAN><EM>ペイロード 2:&nbsp;<SPAN> </SPAN>クロスサイト スクリプティング</EM></SPAN></H2><P><SPAN>レスポンス分割の脆弱性では、2 番目のレスポンスは攻撃者によって完全に制御されています。<SPAN>&nbsp; </SPAN>攻撃者は、分割ページを被害者のコンテキストで実行するスクリプトと共に送信できます。<SPAN>&nbsp; </SPAN>これが、クロスサイト スクリプティング攻撃 (XSS) につながります。<SPAN>&nbsp; </SPAN>攻撃データは次のように表示されます:</SPAN></P><pre><SPAN><STRONG>0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2052%0d%0a%0d%0a&lt;html&gt;&lt;script&gt;alert('document.cookie')&lt;/script&gt;&lt;/html&gt;</STRONG></SPAN><SPAN></SPAN></pre><P><SPAN>この攻撃のペイロードは比較的害がなく、単なるアラート ボックスです。 より高度なペイロードでは、攻撃者によって制御されているサイトにセッション認証情報を送信することもあります。 </SPAN></P><H2><SPAN><EM>ペイロード 3: Web キャッシュ ポイズニング</EM></SPAN></H2><P><SPAN>このよく知られているシナリオではインターネット ブラウザ クライアントが目的ではありません。 目的は Web キャッシュ サーバーです。<SPAN>&nbsp;&nbsp; </SPAN>攻撃者は最初のリクエストを Web キャッシュ サーバーから行って、 2 つに分割したパケットを受け取ります。<SPAN>&nbsp;&nbsp; </SPAN>攻撃者はその後 2 番目のリクエストを任意のリソースに送信します。<SPAN>&nbsp; </SPAN>キャッシュ サーバーは 2 番目のリクエストを分割レスポンス (攻撃者によって制御) と一致させます。<SPAN>&nbsp;&nbsp; </SPAN>これにより、攻撃は Web キャッシュ サーバーの任意のユーザーに伝搬されます。 攻撃文字列は、キャッシュに関係するヘッダを操作します:</SPAN></P><pre><SPAN><STRONG>http://vulnsite.com/redirect.php?page=%0d%0aContent-Type: text/html%0d%0a%0d%0aHTTP/1.1 200 OK%0d%0aLast-Modified: Wed, 13 Jan 2010%0d%0aContent-Type: text/html%0d%0a%0d%0a&lt;html&gt;&lt;</STRONG><SPAN><STRONG>font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; HTTP/1.</STRONG>1</SPAN></SPAN></pre><P><SPAN>シナリオは以下の手順に従います:</SPAN></P><OL><LI><SPAN>攻撃者は、脆弱なサーバーによって分割 (<I>a1</I> と <I>a2</I>) されるリクエスト <I>A</I> を Web キャッシュ サーバーに送信します。</SPAN><LI><SPAN>キャッシュ サーバーはこのリクエスト <I>A</I> を脆弱なサーバーに転送します。</SPAN><LI><SPAN>脆弱なサーバーは、<I>a1 </I>と <I>a2</I> の 2 つのレスポンスを順番にキャッシュ サーバーに送信します。</SPAN><LI><SPAN>キャッシュ サーバーはキャッシュに関連付けられたリソース <I>A</I> のエントリを <I>a1</I> に追加します。</SPAN><LI><SPAN>攻撃者はリクエスト <I>B</I> を Web キャッシュ サーバーに送信します。</SPAN><LI><SPAN>キャッシュ サーバーはキャッシュに関連付けられたリソース <I>B</I> のエントリを <I>a2</I> に追加します。</SPAN></LI></OL><P><SPAN>攻撃者は <I>a2 </I>を完全に制御しているため、キャッシュのリソース <I>B</I> を意のままに有害にすることができます。</SPAN></P><P><SPAN>[</SPAN><SPAN>最終更新日</SPAN><SPAN> </SPAN><SPAN>] ヘッダを未来の日付に設定すると、キャッシュ サーバーは、元のサーバーに接続して有効なドメインからページを要求する代わりに、攻撃者のページを返します。<SPAN>&nbsp; </SPAN>攻撃者はまた、</SPAN><SPAN>Cache-Control </SPAN><SPAN> または </SPAN><SPAN>Pragma</SPAN><SPAN> ヘッダを使用してキャッシュ サーバーがレスポンスを処理してその記録を更新する方法も制御します。</SPAN></P><H2><SPAN><EM>ペイロード 4: ページ ハイジャック</EM></SPAN></H2><P><SPAN>この攻撃はプロキシ サーバー経由で達成されます。<SPAN>&nbsp; </SPAN>攻撃者は慎重にタイミングを見計らう必要があります。というのも、正確な時間にリクエストを行って、正規ユーザーによって前に行われたレスポンスを送り返す必要があるからです。<SPAN>&nbsp; </SPAN>シナリオでは次の特定の手順に従います [ii]:</SPAN></P><OL><LI><SPAN>攻撃者は、脆弱な Web サーバーによって分割 (<I>a1</I> と <I>a2</I>) されるリクエストをプロキシ サーバー <I>A</I> に送信します。</SPAN><LI><SPAN>プロキシ サーバーはこのリクエスト <I>A</I> を脆弱なサーバーに転送します。</SPAN><LI><SPAN>脆弱なサーバーは、<I>a1 </I>と <I>a2</I> の 2 つのレスポンスを順番にキャッシュ サーバーに送信します。</SPAN><LI><SPAN>プロキシ サーバーは攻撃者に <I>a1 </I>を転送して <I>a2</I> を保持します。</SPAN><LI><SPAN>被害者のクライアントは機密ページのリクエスト <I>B</I> をプロキシ経由で Web サーバーに送信します。</SPAN><LI><SPAN>プロキシは <I>B</I> を Web サーバーに転送します。</SPAN><LI><SPAN>プロキシは 2 番目のレスポンスをサーバー <I>a2 </I>から被害者のクライアントに送信します (レスポンス <I>b</I> の代わりに)。</SPAN><LI><SPAN>プロキシは Web サーバーからレスポンス <I>b </I>を受け取ります。</SPAN><LI><SPAN>攻撃者はプロキシを介して Web サーバーにリクエスト <I>C</I> を送信します。</SPAN><LI><SPAN>プロキシ サーバーはレスポンス <I>b</I> を攻撃者に送信します (レスポンス <I>c</I> の代わりに)。</SPAN></LI></OL><P><SPAN>攻撃者は予期しないレスポンスを通信フローに挿入できたため、プロキシ サーバーは不適切なクライアント (攻撃者) に機密データが含まれたレスポンス <I>b</I> を送信します。<SPAN>&nbsp; </SPAN></SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>手順 2: <SPAN> </SPAN>原因と対応策を分析する</SPAN></H1><P><SPAN>次の手順では、HTTP レスポンス分割の脆弱性の原因と、防御する方法を理解します。<SPAN>&nbsp;&nbsp; </SPAN>この説明では、ソース コードベースの攻撃クラスを認識できるようにし、コーディングのベスト プラクティスを使用します。</SPAN></P><H2><SPAN><EM>HTTP レスポンス分割の原因</EM></SPAN></H2><P><SPAN>HTTP プロトコル仕様では、各ヘッダはキャリッジ リターン文字 (CR, ASCII 0x0D) によって区切られていて、ライン フィード文字 (LF, ASCII 0x0A) がそれに続き、文字列 </SPAN><SPAN>CR/LF</SPAN><SPAN> で表示されます。<SPAN>&nbsp; </SPAN>さらに、レスポンス ヘッダは本体が 2 つ (</SPAN><SPAN>CR/LF/CR/LF) に分割されています。 </SPAN></P><P><SPAN>HTTP レスポンス分割攻撃は、</SPAN><SPAN>CR/LF</SPAN><SPAN> 文字列を</SPAN><SPAN> </SPAN><SPAN>HTTP ヘッダに挿入することによって機能します。<SPAN>&nbsp; </SPAN></SPAN><SPAN>CR/LF </SPAN><SPAN>をチェックせずにヘッダを構築する Web アプリケーションはこの攻撃に対して脆弱です。<SPAN>&nbsp; </SPAN>ヘッダの構築に使用したデータのチェックと不正な </SPAN><SPAN>CR/LF</SPAN><SPAN> の削除に失敗したことが、攻撃を許し、この脆弱性の原因となっています。</SPAN></P><P><SPAN>使用する言語に応じて HTTP ヘッダを構築する関数はさまざまにあります。</SPAN></P><TABLE><TBODY><TR><TD><P><B><SPAN>クラス関数/プロパティ</SPAN></B></P></TD><TD><P><B><SPAN>言語</SPAN></B></P></TD></TR><TR><TD><pre><SPAN>response.setContentType(), &lt;CODE&gt;response.setHeader() &lt;/CODE&gt;</SPAN></pre><pre><SPAN>HttpServletResponse.setHeader(),</SPAN></pre><pre><SPAN>HttpServletResponse.addHeader(),</SPAN></pre><pre><SPAN>HttpServletResponse.setIntHeader(),</SPAN></pre><pre><SPAN>HttpServletResponse.addIntHeader(),</SPAN></pre><pre><SPAN>HttpServletResponse.setDateHeader(),</SPAN></pre><pre><SPAN>HttpServletResponse.addDateHeader(),</SPAN></pre><pre><SPAN>pServletResponse.setContentType(),</SPAN></pre></TD><TD><P><SPAN>Java</SPAN></P></TD></TR><TR><TD><P><SPAN>Response.Headers.Set(), HttpResonse.Redirect(), HttpResponse.setCookie(),</SPAN><SPAN> </SPAN><SPAN>HttpResponse.HeaderName</SPAN><SPAN></SPAN></P></TD><TD><P><SPAN>ASP .NET</SPAN></P></TD></TR><TR><TD><P><SPAN>header()</SPAN></P></TD><TD><P><SPAN>PHP</SPAN></P></TD></TR></TBODY></TABLE><P><SPAN>&nbsp;</SPAN></P><P><SPAN>この攻撃の被害者が Web クライアントであったとしても、これはサーバー側のバグであることに留意してください。</SPAN></P><H2><SPAN><EM>HTTP レスポンス分割の対応策</EM></SPAN></H2><P><SPAN>レスポンス分割バグには簡単な解決策があります。それは、クライアントに送信する前に、ヘッダのデータをチェックすることです。<SPAN>&nbsp; </SPAN>絶対に </SPAN><SPAN>CR/LF</SPAN><SPAN> 文字 (</SPAN><SPAN>%0d%0a</SPAN><SPAN>) およびその他のHTTP 特殊文字のデータをチェックする前に、ヘッダにデータを書き込まないでください。<SPAN>&nbsp;&nbsp; </SPAN>別のアプローチとしては、ヘッダに書き込むための安全なパターンを示すホワイト リストを保持します。<SPAN>&nbsp;&nbsp; </SPAN>サーバーはヘッダに書き込むためのデータをチェックし、ホワイト リストの安全なパターンに一致するかどうかを確認します。<SPAN>&nbsp; </SPAN>サーバーはデータが安全なパターンのいずれかに一致した場合にのみヘッダに入力できるようにしますが、安全なパターンに一致しない場合は却下します。</SPAN></P><P><B><SPAN>&nbsp;</SPAN></B></P><H1><SPAN>手順 3: <SPAN> </SPAN>テストと調査を開始する</SPAN></H1><P><SPAN>この手順では、テスト ケースの最初のラウンドを実行して HTTP レスポンス分割バグを検出します。<SPAN>&nbsp; </SPAN></SPAN></P><H2><SPAN><EM>リダイレクトによるレスポンス分割のテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>Web アプリケーションを実行する 1 台のクライアント コンピュータと 1 台のサーバー コンピュータ。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ、ネットワーク モニタリング ツール (Wireshark)。</SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>リダイレクトを行う Web アプリケーションのページを検索します。</SPAN><LI><SPAN></SPAN><SPAN>Location</SPAN><SPAN> ヘッダに書き込まれるパラメータを特定します (このパラメータは一般的に URL 経由で渡されますが、別の方法で転送される可能性があります)。</SPAN><LI><SPAN>リダイレクト ページのアドレスの URL が含まれたリンクで HTML ページを構築 (手順 1) し、二重</SPAN><SPAN> CR/LF </SPAN><SPAN>および追加の HTTP 200 (OK) レスポンスを挿入されたページと共に </SPAN><SPAN>Location</SPAN><SPAN> ヘッダのパラメータ経由で渡します。<SPAN>&nbsp; </SPAN></SPAN><LI><SPAN>クライアント コンピュータで、Wireshark を使用してネットワーク トラフィックのモニタリングを開始します。</SPAN><LI><SPAN>インターネット ブラウザを使用して構築したページを開き、リンクをクリックします。</SPAN><LI><SPAN>クライアントがサーバーからのすべてのレスポンスを受信するまで待機します (これには平均のネットワーク速度で 10 秒もかかりません)。</SPAN><LI><SPAN>ネットワーク トラフィックのモニタリングを停止し、Web サーバーとクライアント間で交換されたパケットを解析します。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN><SPAN>&nbsp;</SPAN>Web サーバーが 2 つのレスポンス (200 OK と 302 Redirect) を送信した場合、およびクライアント ブラウザが挿入されたページを表示した場合、アプリケーションは HTTP レスポンス分割に対して脆弱です。</SPAN></P><H2><SPAN><EM>永続型ストアからのヘッダ構築によるレスポンス分割のテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>Web アプリケーションを実行する 1 台のクライアント コンピュータと 1 台のサーバー コンピュータ。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web browser、ネットワーク モニタリング ツール (Wireshark)、データベース クライアント。</SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>ヘッダの一部としてデータベース レコードを使用する Web アプリケーションによって送信されたレスポンスを検索します。</SPAN><LI><SPAN>データベース クライアントを使用してデータベースに接続します。</SPAN><LI><SPAN>二重</SPAN><SPAN> CR/LF </SPAN><SPAN>および改変されたページを含む追加の HTTP 200 (OK) レスポンスで脆弱なレコードを更新します。</SPAN><LI><SPAN>クライアント コンピュータで、Wireshark を使用してネットワーク トラフィックのモニタリングを開始します。</SPAN><LI><SPAN>データベース データからレスポンスを送信するページを参照します (手順 1)。</SPAN><LI><SPAN>クライアントがサーバーからのすべてのレスポンスを受信するまで待機します (これには平均のネットワーク速度で 10 秒もかかりません)。</SPAN><LI><SPAN>ネットワーク トラフィックのモニタリングを停止し、Web サーバーとクライアント間で交換されたパケットを解析します。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN>最初のテスト ケースと同じです。</SPAN></P><P><B><I><SPAN></SPAN></I></B></P><H2><SPAN><EM>URL を使用してヘッダを構築するレスポンス分割のテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>Web アプリケーションを実行する 1 台のクライアント コンピュータと 1 台のサーバー コンピュータ。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ、ネットワーク モニタリング ツール (Wireshark)。</SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>URL パラメータをヘッダの一部として使用する Web アプリケーションによって送信されたレスポンスを検索します。</SPAN><LI><SPAN>二重</SPAN><SPAN> CR/LF </SPAN><SPAN>を含む文字列を渡す手順 1 のページを呼び出すリンクが含まれたページおよび URL パラメータに挿入されたページが含まれる追加の HTTP 200 (OK) レスポンスを構築します。</SPAN><LI><SPAN>クライアント コンピュータで、Wireshark を使用してネットワーク トラフィックのモニタリングを開始します。</SPAN><LI><SPAN>インターネット ブラウザを使用して構築したページを開き、リンクをクリックします。</SPAN><LI><SPAN>クライアントがサーバーからのすべてのレスポンスを受信するまで待機します (これには平均のネットワーク速度で 10 秒もかかりません)。</SPAN><LI><SPAN>ネットワーク トラフィックのモニタリングを停止し、Web サーバーとクライアント間で交換されたパケットを解析します。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN>最初のテスト ケースと同じです。</SPAN></P><P><B><I><SPAN></SPAN></I></B></P><H2><SPAN><EM>HTTP レスポンス分割による反射型クロスサイト スクリプティング (XSS) のテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>Web アプリケーションを実行する 1 台のクライアント コンピュータと 1 台のサーバー コンピュータ。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ。 </SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>リダイレクトまたは URL による HTTP レスポンス分割に対して脆弱なページを検索します (テスト ケース 1 または 3 で失敗)。</SPAN><LI><SPAN>二重</SPAN><SPAN> CR/LF </SPAN><SPAN>を含む文字列を渡す手順 1 の脆弱なページを呼び出すリンクが含まれたページおよびリダイレクトまたは URL パラメータ経由でアラート ボックスをポップする文字列が含まれる追加の HTTP 200 (OK) レスポンスを構築します。</SPAN><LI><SPAN>クライアント コンピュータで、インターネット ブラウザを使用して構築したページを開き、リンクをクリックします。</SPAN><LI><SPAN>クライアントがサーバーからのすべてのレスポンスを受信するまで待機します。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN>テスト ケースはアラート ボックスがポップアップすると失敗します。<SPAN>&nbsp; </SPAN></SPAN></P><P><SPAN></SPAN></P><H2><SPAN><EM>HTTP レスポンス分割による持続型クロスサイト スクリプティング (XSS) のテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>Web アプリケーションを実行する 1 台のクライアント コンピュータと 1 台のサーバー コンピュータ。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ、データベース クライアント。 </SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>データベース レコードまたは永続型ストアによる HTTP レスポンス分割に対して脆弱なページを検索します (テスト ケース 2 で失敗)。</SPAN><LI><SPAN>二重</SPAN><SPAN> CR/LF </SPAN><SPAN>を含む文字列を使用するデータベース レコードまたは永続型ストアおよびリダイレクトまたは URL パラメータ経由でアラート ボックスをポップする文字列が含まれる追加の HTTP 200 (OK) レスポンスを変更します。</SPAN><LI><SPAN>クライアント コンピュータで、Web ブラウザを使用して手順 1 で検索したページを参照します。</SPAN><LI><SPAN>クライアントがサーバーからのすべてのレスポンスを受信するまで待機します。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN><SPAN>&nbsp;</SPAN>テスト ケースはアラート ボックスがポップアップすると失敗します。<SPAN>&nbsp; </SPAN></SPAN></P><P><SPAN></SPAN></P><H2><SPAN><EM>HTTP レスポンス分割による Web キャッシュ ポイズニングのテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>クライアント コンピュータ 2 台、Web キャッシュ サーバー コンピュータ 1 台、およびWeb アプリケーション サーバー 1 台。<SPAN>&nbsp;&nbsp; </SPAN>2 台のクライアントは同じ Web キャッシュ サーバーを使用します。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ。 </SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>HTTP レスポンス分割に対して脆弱なページを検索します (最初の 3 つのテストのうちの 1 つで失敗)。</SPAN><LI><SPAN>クライアント A で、インターネット ブラウザを使用して挿入された HTML ページと共に二重</SPAN><SPAN> CR/LF </SPAN><SPAN>および追加の HTTP 200 (OK) レスポンスが含まれたリクエストをアプリケーション サーバーに送信します。<SPAN>&nbsp;&nbsp; </SPAN>キャッシュ ヘッダを追加のレスポンスに設定し、サーバーがページをキャッシュするようにします。 クライアントがこのリクエストを Web キャッシュ サーバーに送信すると、リクエストはアプリケーション サーバーに転送されます。</SPAN><LI><SPAN>クライアント A で、クライアントがサーバーからのレスポンスをすべて受信するまで待機 (これには平均のネットワーク速度で 10 秒もかかりません) し、ブラウザに表示される最後のレスポンスを観察します。</SPAN><LI><SPAN>クライアント A で、クライアントに対する別のリクエストをターゲット リソースに行います。<SPAN>&nbsp; </SPAN>これにより、攻撃がトリガされます。<SPAN>&nbsp;&nbsp; </SPAN>アプリケーション サーバーが脆弱である場合、キャッシュ サーバーはこのリクエストを手順 2 で挿入されたレスポンスに関連付けます。</SPAN><LI><SPAN>クライアント B で、手順 4 でターゲットにした同じリソースにリクエストを行います。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN><SPAN>&nbsp;</SPAN>クライアント B が手順 5 で行われたリクエストに対して挿入されたレスポンスを手順 2 から取得した場合、テスト ケースは失敗します。</SPAN></P><P><SPAN>&nbsp;</SPAN></P><H2><SPAN><EM>HTTP レスポンス分割によるページ ハイジャックのテスト</EM></SPAN></H2><P><SPAN>ハードウェア要件:&nbsp;<SPAN> </SPAN>クライアント コンピュータ 2 台、Web キャッシュ サーバー コンピュータ 1 台、および Web アプリケーション サーバー 1 台。<SPAN>&nbsp;&nbsp; </SPAN>2 台のクライアントはプロキシ サーバーを使用します。</SPAN></P><P><SPAN>ツール:&nbsp;<SPAN>&nbsp; </SPAN>Web ブラウザ。</SPAN></P><P><SPAN>テストの手順:</SPAN></P><OL><LI><SPAN>HTTP レスポンス分割に対して脆弱なページを検索します (最初の 3 つのテストのうちの 1 つで失敗)。</SPAN><LI><SPAN>ネットワーク傍受ツールをプロキシにフックして送信パケットをすべて傍受します。</SPAN><LI><SPAN>クライアント A で、インターネット ブラウザを使用して改変された HTML ページと共に二重</SPAN><SPAN> CR/LF </SPAN><SPAN>および追加の挿入された HTTP 200 (OK) レスポンスが含まれたアプリケーション サーバーにリクエストを送信します。<SPAN>&nbsp;&nbsp;&nbsp; </SPAN>クライアントはこのリクエストをプロキシから送信します。</SPAN><LI><SPAN>クライアント B で、インターネット ブラウザを開いて機密ページを参照します。</SPAN><LI><SPAN>クライアント A で、任意の Web ページにリクエストを行います。</SPAN></LI></OL><P><SPAN>予想される結果:&nbsp;<SPAN> </SPAN><SPAN>&nbsp;</SPAN>クライアント A が手順 4 でクライアント B によってリクエストされた機密ページへのレスポンスを取得した場合、テスト ケースは失敗します。</SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>手順 4: <SPAN> </SPAN>テスト ケース データを微調整する</SPAN></H1><P><SPAN>この手順では、エントリ ポイントごとにテスト ケース データを調整し、最初の HTTP レスポンスを終了することによってレスポンスを確実に分割する一方で、テスト ケースを前の手順から繰り返す必要があります。 </SPAN></P><H2><SPAN><EM>エントリ ポイントに応じてテスト ケース データ形式を調整する</EM></SPAN></H2><P><SPAN>テスト ケース データの形式は、それを送信するために使用されるエントリ ポイントによって異なります。<SPAN>&nbsp; </SPAN>たとえば、URL からテストを行っている場合、次の 2 つの文字列は使用されている URL エンコーディング スキームに応じて同等です:</SPAN></P><pre><SPAN>%0d%0aContent-Type:%20text/html%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a%3Chtml%3E%3Cfont%20color=red%3EAttacked!!%3C/font%3E%3C/html%3E</SPAN></pre><pre><SPAN>%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2047%0d%0a%0d%0a&lt;html&gt;&lt;font%20color=red&gt;Attacked!!!&lt;/font&gt;&lt;/html&gt;</SPAN></pre><P><SPAN></SPAN></P><P><SPAN>同様に、リダイレクト ページ、URL パラメータ、Web フォーム入力フィールド、Web サービス メソッド、環境変数、データベース コンテンツなど、任意のエントリ ポイントのデータ形式に応じてテスト データを調整する必要があります。</SPAN></P><H2><SPAN><EM>最初のレスポンスを終了する</EM></SPAN></H2><P><SPAN>HTTP レスポンス分割の課題は、Web サーバーにオリジナル レスポンスを終了して分割されたレスポンスを開始するように伝えることです。<SPAN>&nbsp; </SPAN>Web サーバーによってはレスポンスの必要最低限の長さがある場合があります。<SPAN>&nbsp; </SPAN>これは、レスポンスを特定の長さよりも短くすることはできないという意味です。<SPAN>&nbsp; </SPAN>サーバーがレスポンスを終了して新しいレスポンスを開始できるように、挿入されたデータを調整して最初のレスポンスを埋める必要があります。<SPAN>&nbsp; </SPAN></SPAN><SPAN>Content-Length</SPAN><SPAN> がゼロに設定されている場合は他の Web サーバーはレスポンスを終了します。<SPAN>&nbsp;&nbsp;&nbsp; </SPAN>異なるプラットフォームでテストを行う場合、高度な埋め込みの留意事項については以下のリファレンスを参照してください。</SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>結論</SPAN></H1><P><SPAN>HTTP レスポンス分割は、フィッシング、XSS、Web キャッシュ ポイズニングなど、異なる攻撃を容易にする新しい攻撃クラスです。<SPAN>&nbsp; </SPAN>リソース分割バグのテストでは、これらの異なる攻撃をすべて網羅する必要があります。 攻撃シナリオについて理解し、各テスト ケースを綿密に実行することが重要です。<SPAN>&nbsp; </SPAN>最後に、すべてのエントリ ポイントが網羅されていて、形式に応じてテスト データが微調整されていることを確認してください。</SPAN></P><P><SPAN>&nbsp;</SPAN><SPAN>&nbsp;</SPAN></P><DIV><BR></DIV><DIV><HR></DIV><P>[i] <B><SPAN>HTTP レスポンス分割。<SPAN>&nbsp; </SPAN></SPAN></B><SPAN>Diabolic Crab<B>。</B><A href="http://www.infosecwriters.com/text_resources/pdf/HTTP_Response.pdf">http://www.infosecwriters.com/text_resources/pdf/HTTP_Response.pdf</A></SPAN></P><P><SPAN>&nbsp;</SPAN></P><P>[ii]&nbsp;<SPAN> <B>分割統治。 HTTP レスポンス分割、Web キャッシュ ポイズニング攻撃、および関連トピック</B><SPAN>&nbsp; </SPAN>Amit Klein, Sanctum Inc.<SPAN>&nbsp; </SPAN><A href="http://packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf">http://packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf</A></SPAN></P><P><SPAN>&nbsp;</SPAN></P>


]]></Data>
  </Content>
</TeamMentor_Article>