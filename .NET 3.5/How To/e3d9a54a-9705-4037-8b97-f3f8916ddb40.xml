<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-2102397688" Content_Hash="-941124176">
  <Metadata>
    <Id>e3d9a54a-9705-4037-8b97-f3f8916ddb40</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>ASP.NET 内にパス改ざんバグがないかどうかテストする方法</Title>
    <Category>入力とデータの検証</Category>
    <Phase>テスト</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>概要</h1>
  <p>パス操作攻撃では、攻撃者はアプリケーションが使用する内部ファイルパスを変更するために特定の入力を送信し、アプリケーションが悪意のあるパスを使用するように強制します。 攻撃者は、サーバ上で構成ファイルまたは別のユーザーのファイルのような機微なファイルを読み取るほか、サーバ側のファイルを変更または削除するためにこのバグを悪用する可能性があります。 </p>
  <p>ASP.NETでパス操作バグをテストするには、次の手順に従います。</p>
  <ul>
    <li>手順 1: 攻撃のシナリオを理解する<li>手順 2: 原因と対策を分析する<li>手順 3: テストと調査を開始する<li>手順 4: 追加テストを実行する</li></li></li></li>
  </ul>
  <p>&nbsp;</p>
  <h1>手順 1: 攻撃のシナリオを理解する</h1>
  <p>パス操作バグをテストする最初の手順は、攻撃シナリオの詳細を理解することです。 </p>
  <p>この脆弱性をエクスプロイトするために、攻撃者は HTTP リクエスト内のファイル パスを操作します。 アプリケーションに脆弱性がある場合、その操作されたファイル パスでファイル システム操作が実行されます。 この攻撃では、まず攻撃者が、ファイルの読み取り、修正、削除、メール送信、印刷などのサーバー側のファイル システム操作を呼び出す HTTP リクエストを見つけます。 この要求は、ウェブページ、またはクライアント側スクリプト（例えば、AJAXアプリケーション内の）のいずれかに由来し、サーバがどのファイルを扱うか判断するために使用する変数（URLパラメータ、ウェブフォーム入力など）が含まれています。 &nbsp;攻撃を実行するために、攻撃者は要求を送信しますが、サーバ側のファイルを操作しようとこの変数を変更し、悪意のある目的のためにアプリケーションの意図された機能を悪用します。 攻撃が成功すると、攻撃者が提供した値によってサーバーでは異なるパスでファイルがアクセスされます。 多くの場合、攻撃者は攻撃を実行して間もなく、攻撃に成功したかどうかを判断できます。</p>
  <p>詳細: </p>
  <ol>
    <li>攻撃者が、サーバーのファイル システム操作を呼び出す HTTP リクエストを見つけます。<li>攻撃者は、ファイルシステム操作のためのパスを決定するのに使用するHTTP要求内の変数の位置を見つけます。<li>攻撃者は、要求を送信しますが、変数を決定するパスを変更して、サーバからの応答を待ちます。<li>攻撃者は、サーバーの応答を観察して、攻撃が成功したかどうかを確認します。</li></li></li></li>
  </ol>
  <h2>
    <em>
      <br />さまざまな攻撃</em>
  </h2>
  <p>攻撃者はパス操作攻撃を使用して、さまざまな脅威をもたらします。 例えば、攻撃者はパスを操作することで、サーバ構成およびパスワードファイルを読み取る、もしくは別のユーザーに属するファイルを読み取ることで、アプリケーションの情報漏えい攻撃を実行できます。 &nbsp;同様に、攻撃者はパスを操作することで、ASP.NETアプリケーションがユーザーに適切にサービスを提供するために必要なファイルを削除することを強制し、DoS攻撃の状況をつくることができます。</p>
  <p>&nbsp;</p>
  <h1>手順 2: 原因と対策を分析する</h1>
  <p>次に、実用的なテストケースを実行する前に、これらのバグがなぜ存在するのか、そしてどのようにして回避できるかを理解することが必要です。</p>
  <p>パス操作バグは、ファイルパスを構築するためにクライアントから提供された入力を使用するASP.NETアプリケーションに影響を与えます。 たとえば、以下のコードは<i>filename</i>という名のURL パラメータとしてユーザーから入力値を入手します:</p>
 <pre>string filename = "/public/user_files/" + <br />Server.UrlDecode(Request.QueryString["filename"]);&nbsp;&nbsp;&nbsp; <br />&nbsp;<br />StreamReader streamReader = new StreamReader(filename);<br />while (streamReader.Peek() &gt;= 0)<br />{<br />	Response.Write(streamReader.ReadLine());<br />}<br />streamReader.Close();</pre>
  <p />
  <p>ユーザーが、<i>file.txt</i> などの予想されるファイル名を提供する場合は、予想されるユーザー ファイルがアプリケーションから返されます。</p>
 <pre>http://example.com.pe/example.aspx?filename=<strong>file.txt</strong></pre>
  <p>
    <b>
    </b>
  </p>
  <p>しかし、パス操作シナリオでは、攻撃者は変数の悪意のある値を提供し、アプリケーションが別のファイルパスを判別することを狙います:</p>
 <pre>http://example.com.pe/example.aspx?filename=<strong>../../private/secret.txt</strong></pre>
  <p>
    <b>
    </b>
  </p>
  <p>上の文字列により、アプリケーションは、2つのディレクトリを上がり、 <i>private</i> フォルダに移動し、 <i>secret.txt.を表示します。</i> 上の例は、パス操作による情報漏えいの一般的なシナリオです。 Notice that the attack is possible because the code shown trusts the filename provided by the client; it starts by directly copying the input to the internal variable used to determine the filename, without properly validating it.</p>
  <p>このバグを防ぐためには、ASP.NETアプリケーションが適切にユーザー入力を検証する必要があります。 特に、ファイル パスの決定にその入力が使用されても安全かどうかがチェックされる必要があります。 開発者は、".. /" （から引用符を取り除いたもの）などの、禁止されているファイル名構成要素が全て含まれているブラックリストを使用し、ユーザーの入力がブラックリストに表示されているかチェックすることができます。 ブラックリストの問題点は、考慮されていない攻撃のバリアントは全て気付かれずに実行されるということです。 有効であるためには、ブラックリストはあらゆる攻撃のバリアントを100％すべて考慮する必要がありますが、実際には無理です。 このバグを防ぐために推奨されるアプローチは<i>ホワイトリストを使用することです。 </i>ホワイトリストでは、安全な構成のみが指定されていて、指定された安全な構成と一致しないユーザー入力は許されません。 これを行うことにより、良いものを指定するだけで、攻撃バリアントの100％すべてを考慮する必要はなくなります。 </p>
  <p>ホワイトリストを実装する一般的な方法は、正規表現を使用してなにが安全かを指定し、正規表現に一致しないすべての入力を許可しないようにすることです：</p>
 <pre>Regex validFilename = new Regex("^[a-zA-Z]{4,8}\.txt$");<br />string input = Server.UrlDecode(Request.QueryString["filename"]);<br />&nbsp;<br />if (!validFilename.IsMatch(input))<br />{<br />	Response.Write("invalid input");<br />}<br />else<br />{<br />	string filename = "/public/user_files/" +<br />	&nbsp;&nbsp; Server.UrlDecode(Request.QueryString["filename"]);<br />&nbsp;<br />&nbsp;	StreamReader streamReader = new StreamReader(filename);<br />	while (streamReader.Peek() &gt;= 0)<br />	{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 		Response.Write(streamReader.ReadLine());<br />	}<br />	streamReader.Close();<br />}</pre>
  <p>入力は、4～8の連続した大文字または小文字に拡張子<i>“.txt”</i>を付け加えたもので構成される必要があります。 この形式と一致しないすべての入力に対して、アプリケーションから "<i>無効な入力</i>" エラーが返されます。</p>
  <p>&nbsp;</p>
  <h1>手順 3: テストと調査を開始する</h1>
  <p>パス操作バグの一般的な攻撃シナリオに加え、その原因と対策が分かったら、基本的なテスト ケースを実行して、アプリケーションに脆弱性があるかどうかを確認する必要があります。</p>
  <p>パス操作バグのテストに成功するかは、アプリケーションがファイルパスを構築するために使用する変数の判断に依存します。 アプリケーションは、一般的にURLとウェブフォームの変数を使用するので、これら2つの入力ポイントを介してテストする方法を理解する必要があります。 </p>
  <h2>
    <em>URL 変数のパス操作のテスト</em>
  </h2>
  <p>以下の手順に従って、URL 変数でのパス操作をテストします。</p>
  <ol>
    <li>インターネット ブラウザーを使用して、ファイル システム操作を実行します。 Note the URL used, such as <i>http://example.com.pe/example.asp?<b>page=index.html</b></i><li>アプリケーションでファイル名を決定するために使用される URL 変数を見つけます (この場合は <i>page</i> です)。 <li>ステップ2で検出した変数値を、攻撃文字列（表1を参照）と置き換えます。 例えば: <i>http://example.com.pe/example.asp?page<b>=</b>../../../boot.ini</i>  <li>アプリケーションに要求を送信し、応答を待ちます。</li></li></li></li>
  </ol>
  <p>予想される結果: アプリケーションは、ファイル パスが操作されたことを示すエラー メッセージを返す必要があります。 応答を決定するのにステップ3で指定したパスが使用され、攻撃者が指定したファイルが応答に使用された場合、アプリケーションには脆弱性があります。</p>
  <h2>
    <em>ウェブフォーム変数内のパス操作をテスト</em>
  </h2>
  <p>ウェブフォームを介したパス操作をテストするには、次の手順に従います。</p>
  <ol>
    <li>ファイル名の入力を求めるプロンプトを表示するウェブフォームを含むページにナビゲートします。<li>アプリケーションでファイル名の決定に使用される変数 (入力フィールド) を見つけます。<li>ファイル名を示すフィールドに攻撃文字列を入力します（表1参照）。 ここで、不正な文字が含まれる攻撃文字列の入力を拒否する可能性があるクライアント側のチェックをすべて無効にしておくことが重要です。 詳細については、 <i> Client-side Validationをバイパスするバグのテスト方法</i>をお読みください。 <li>アプリケーションに要求を送信し、応答を待ちます。</li></li></li></li>
  </ol>
  <p>予想される結果は、以前のテストケースと同じです。</p>
  <h2>
    <em>攻撃文字列</em>
  </h2>
  <p>以下の攻撃文字列には、パス操作文字 (ドット、スラッシュ、バックスラッシュ) および異なるエンコーディングでの一般的な Unix または Windows 関連のファイル パスが含まれています。 サーバ上のウェブアプリケーションの相対的な位置に応じて、攻撃を実現するために必要な “../” や “..\” 句の数を変える必要がある場合があります。 </p>
  <table>
    <tbody>
      <tr>
        <td>
 <pre>../etc/passwd<br />..\boot.ini<br />../boot.ini<br />folder_name/file_name<br />..\..\folder_name\file_name<br />../../folder_name/file_name<br />C:\boot.ini<br />%2e%2e\%2e%2e\<br />..%2f..%2f<br />%2e%2e%2f%2e%2e%2ffolder_name%2ffile_name<br />..%2f..%2ffolder_name%2ffile_name<br />..%c0%af..%c0%affolder_name..%c0%affile_name </pre>
        </td>
      </tr>
    </tbody>
  </table>
  <p />
  <p>
    <b>表1 - パス操作攻撃文字列</b>
  </p>
  <h2>
    <em>ファイル操作を示すエラー メッセージの発見</em>
  </h2>
  <p>前述の基本的なテストケースを実行している間、異なるタイプのエラーメッセージを探すことが重要です。 「invalid input（無効な入力）」または「incorrect format（不正なフォーマット）」エラーメッセージはアプリケーションが安全であることを示す一方、「file not found（ファイルが見つかりません）」や「HTTP 404」エラーは、異なるパスでアプリケーションがファイル検索に攻撃文字列を使用しているか、このバグに脆弱である可能性を示します。</p>
  <p>
    <b>&nbsp;</b>
  </p>
  <h1>手順 4: 追加テストを実行する</h1>
  <p>最後に、二重エンコーディングのシナリオに対する追加のテストを実行するだけでなく、アプリケーションの入力ポイントのすべてをカバーすることが重要です。<b><i></i></b></p>
  <h2>
    <em>2 重エンコーディングのシナリオの包含</em>
  </h2>
  <p>この攻撃はウェブアプリケーションに悪意のある入力を渡すよう要求するので、適切に対処するために二重エンコーディングのテストケースを追加する必要があります。 二重エンコーディングは、パーセントエンコードされた値のパーセント記号（%）を、さらにパーセントエンコードされたもの（%25）として再エンコードすることです。 例えば、最初のURLを第2のURLに翻訳するなど：</p>
 <pre>../../&nbsp; (no encoding)</pre>
 <pre>..%2f..%2f&nbsp;&nbsp;&nbsp;&nbsp; (single encoding)</pre>
 <pre>..%252f..%252f (double encoding)</pre>
  <p>使用するすべての攻撃文字列に対して、二重エンコーディングされたテストケースを追加してください。 二重エンコーディング攻撃についての詳細は<i>二重エンコーディングバグのテスト方法をお読みください。</i><i>&nbsp;</i></p>
  <h2>
    <em>すべての入力箇所を使用したテスト</em>
  </h2>
  <p>パス操作攻撃は通常、URLやウェブフォームを通じて起こりますが、追加のアプリケーション入力ポイントを確認することが重要です。 Webアプリケーションは、クライアントのCookie、ウェブメソッド、拡張フレームワーク（Flash / Flexなど）、およびサード パーティのAPI（Facebookなど）のパラメータから入力を得ることができます。 入力を受け取るすべての場所でパス操作をテストする必要があります。</p>
  <p>&nbsp;</p>
  <h1>結論</h1>
  <p>パス操作バグを使用して、攻撃者はサーバー側のファイルにアクセスし、情報漏えいや DoS 攻撃などの攻撃を実行できます。 それらは、アプリケーションがホワイトリストに対してユーザー入力を正常に検証せず、ドットやスラッシュなどのパス操作文字のプロセスを許可するために発生します。 この脆弱性をテストするためには、攻撃文字列が使用されていることを示すエラーメッセージを探す一方で、一般的にはURLまたはウェブフォームで送信される変数を決定するファイルパスを識別し、攻撃文字列に置き換える必要があります。 最後に、このバグの適切なテストカバレッジを達成するためには、二重エンコーディングのシナリオを考慮し、アプリケーションの入力内容をすべてテストすることを確認してください。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>]]></Data>
  </Content>
</TeamMentor_Article>