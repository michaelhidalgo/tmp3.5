<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1686201939" Content_Hash="-24302990">
  <Metadata>
    <Id>3ee9030a-150f-4b45-ad10-d0dda6f4f47a</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>ASP.NET 内に反射バグがないかどうかテストする方法</Title>
    <Category>認証</Category>
    <Phase>テスト</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>ASP.NET 3.5</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    <span>対象</span>
  </h1>
  <ul>
    <li>認証を実施する ASP.NET アプリケーション</li>
  </ul>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <h1>
    <span>要約</span>
  </h1>
  <p>相互認証に Diffie-Hellman のようなアルゴリズムであるチャレンジ/応答を使用してクライアントを認証する ASP.NET アプリケーションは、リフレクション攻撃に対して脆弱である可能性があります。リフレクション攻撃での攻撃者の主な目標は、認証チャレンジへの答えとして、アプリケーション自身の応答を使用するようにアプリケーションをだますことです。</p>
  <p>ASP.NET のリフレクション バグをテストするには、次の手順に従います。</p>
  <ul>
    <li>手順 1: 攻撃のシナリオを理解する<li>手順 2: 原因と対策を分析する<li>手順 3: テスト ケースを実行する</li></li></li>
  </ul>
  <p>&nbsp;</p>
  <h1>
    <span>ステップ 3: 攻撃シナリオを理解する</span>
  </h1>
  <p>まず、一般的なチャレンジ/応答の相互認証プロセスを見直すことにより、リフレクション攻撃のシナリオの骨格を理解することが必要です。<span>&nbsp;&nbsp; </span>チャレンジ/応答の認証シーケンス中、クライアントはサーバに接続します。<span>&nbsp; </span>サーバは、サーバ チャレンジ <i>sc</i> をクライアントへ送信します。<span>&nbsp; </span>クライアントは、次にアプリケーションに対する独自のクライアント チャレンジ と<i> </i>共にクライアントの応答 <i>cr </i> を送信することによりチャレンジへの応答を完了する必要があります。<span>&nbsp;&nbsp; </span>アプリケーションで、クライアントのレスポンス <i>cr</i> を確認することで、クライアントの認証が行われ、サーバー レスポンス <i>sr</i> を使用してクライアントのチャレンジ cc  に対する応答が行われます。<i> </i><span>&nbsp; </span>それを受け、クライアントによってサーバー レスポンス <i>sr</i> が認証され、相互認証が完了します。</p>
  <p>詳細: </p>
  <ol>
    <li>クライアントがサーバーに接続されます。<li>サーバーによってサーバー チャレンジ sc が送信されます。<i> </i><li>サーバーのチャレンジに対して、クライアントで独自のチャレンジ <i>cc</i> が作成され、クライアントのレスポンス <i>cr</i> とともに送信されます。<li>サーバーは、クライアントのレスポンス cr を認証します。<i> <span>&nbsp; </span></i><span>&nbsp;</span>クライアントのチャレンジに対して、サーバーは独自のレスポンス <i>sr</i> を送信します。<li>クライアントは、サーバーのレスポンス sr を認証します。<i>sr</i></li></li></li></li></li>
  </ol>
  <p>リフレクション バグをエクスプロイトするため、攻撃者はターゲットとするアプリケーションに接続します。するとアプリケーションは攻撃者にターゲット チャレンジ <i>tc</i> を送ります。<span>&nbsp;&nbsp; </span>攻撃者は、認証を完了するのに必要なターゲットからのチャレンジへの応答方法を知らないので(攻撃者は共有の秘密を知らない)、ターゲット アプリケーションに対し第 2 の接続を開き、ターゲット チャレンジ <i>tc</i> を自らのチャレンジとしてアプリケーションに送ります。<span>&nbsp;&nbsp; </span>攻撃者はターゲット アプリケーションがチャレンジに応答し、2 つ目の接続を通じてターゲット レスポンス <i>tr</i> を送信するまで待ち、1 つ目の接続を通じてこのレスポンスを独自のレスポンスとして使用し、認証を完了します。</p>
  <p>詳細: </p>
  <ol>
    <li>攻撃者はターゲット アプリケーションに接続します。<li>ターゲットによって攻撃者にチャレンジ tc が送信されます。<i> </i><li>攻撃者はターゲットとの 2 つ目の接続を開き、2 つ目の接続を通じて、攻撃者独自のチャレンジとしてターゲット チャレンジを送信します (<i>ac = tc</i>)。<li>2 つ目の接続を通じて、ターゲットはターゲット レスポンス tr を使用して、攻撃者のチャレンジに応答します。<i> </i><li>元の接続を通じて、攻撃者は独自のレスポンスとしてターゲット レスポンスを使用します (<i>ar = tr</i>)。 <li>元の接続を通じて、ターゲットは攻撃者のレスポンス <i>ar</i> を確認し、攻撃者を認証します。</li></li></li></li></li></li>
  </ol>
  <p>&nbsp;</p>
  <h1>
    <span>手順 2: 原因と対策を分析する</span>
  </h1>
  <p>次にリフレクション バグを起こす原因とその対策を理解する必要があります。<span>&nbsp;&nbsp; </span></p>
  <h2>
    <span>
      <em>セキュアでないプロトコル設計</em>
    </span>
  </h2>
  <p>リフレクション攻撃が可能になるのは、相互認証プロトコルの実装の不備が原因です。<span>&nbsp; </span>例えば、以前のシナリオでは、攻撃者は認証を開始することができ、アプリケーションは自己の応答を自己のチャレンジに対する答えとして受け入れます。<span>&nbsp;&nbsp; </span>アプリケーションは、<i>nonce</i> (一度使用された番号)を使用することでリフレクション攻撃を防御できます。<span>&nbsp; </span>クライアントがアプリケーションに接続すると、アプリケーションはその特定の接続用の nonce をクライアントにサーバー チャレンジ sc として送信されます。<i> <span>&nbsp; </span></i>その後クライアントは、共有鍵 K を使用して暗号化された nonce とともに識別子を送信します。<i> <span>&nbsp; </span></i><span>&nbsp;</span>アプリケーションは、次にクライアントが送信してきたメッセージを復号化します。<span>&nbsp; </span>アプリケーションは、送り返されたnonce が接続のときの元の nonce かどうかチェックして、応答が別のチャレンジへの応答でないことを確認します。<span>&nbsp; </span>リフレクション攻撃を避けるためには、アプリケーションは過去に使用された、または複数の接続で使用されている nonce を検知して拒否します。</p>
  <p>プロトコル設計が非セキュアとなるのは、実装および認証スキームが不完全な ASP.NET アプリケーションで発生します。<span>&nbsp; </span>ほとんどの場合、ASP.NET アプリケーションでは、クライアントがアプリケーションにログインするために認証を使用しています。<span>&nbsp;&nbsp;&nbsp; </span>その場合、開発者はクライアントのセッション環境が簡単なASP.NET の Forms Authentication および開発者から抽出したログイン フォームを使用するよう推奨されます。<i></i><span>&nbsp;&nbsp; </span></p>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <h1>
    <span>ステップ 3: テスト ケースの実行</span>
  </h1>
  <p>リフレクション攻撃の概要を確認したら、今度はアプリケーションに脆弱性があるかどうかを確認するための実際のテスト事例を実行する必要があります。</p>
  <h2>
    <span>
      <em>リフレクション バグのテスト</em>
    </span>
  </h2>
  <p>以下の手順に従って、リフレクション バグをテストします。</p>
  <ol>
    <li>ターゲット アプリケーションに接続して認証を開始してください。<i></i><span>&nbsp; </span>アプリケーションによってチャレンジが送信されるまで待ちます。<li>ターゲットに対し第 2 の接続を開いて、この接続を通じて以前のステップからのターゲット チャレンジを送信してください。<span>&nbsp; </span>チャレンジに対するレスポンスがターゲット アプリケーションから送信されるまで待ちます。<li>前の手順でアプリケーションから送信されたレスポンスを、元の接続を通じて送信します。</li></li></li>
  </ol>
  <p>予測される結果:<span>&nbsp; </span>手順 3 で正常に認証を行うことができた場合は、アプリケーションはリフレクション攻撃に対して脆弱性があります。</p>
  <p>&nbsp;</p>
  <h1>
    <span>結論</span>
  </h1>
  <p>リフレクション攻撃は、相互認証プロトコルを使用してアプリケーションの論理欠陥をエクスプロイトすること、およびアプリケーション自身の応答を使用してアプリケーション チャレンジに応答することに重点を置いています。<span>&nbsp; </span>このバグをテストするには、攻撃シナリオおよびその原因と対策を理解することから始めることをお勧めします。<span>&nbsp; </span>その後、ASP.NET アプリケーションが脆弱かどうかをチェックするため、簡単なテスト ケースを実施します。</p>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <p>
    <b>
      <i>
        <span>&nbsp;</span>
      </i>
    </b>
  </p>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>]]></Data>
  </Content>
</TeamMentor_Article>