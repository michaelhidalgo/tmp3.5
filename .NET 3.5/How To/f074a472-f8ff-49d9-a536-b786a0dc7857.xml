<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="405393725" Content_Hash="463052389">
  <Metadata>
    <Id>f074a472-f8ff-49d9-a536-b786a0dc7857</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>リバース エンジニアリング バグのテスト方法</Title>
    <Category>設計上の考慮事項</Category>
    <Phase>テスト</Phase>
    <Technology> 任意</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    <span>対象</span>
  </h1>
  <ul>
    <li>すべてのソフトウェア アプリケーション</li>
  </ul>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <h1>
    <span>要約</span>
  </h1>
  <p>ソフトウェアのリバース エンジニアリングとは、あるアプリケーション ソフトウェアが作成されてリリースされた後に、そのアプリケーションのアーキテクチャ、設計、実装の詳細について推測するプロセスです。<span>&nbsp; </span>通常、この攻撃は、標的となるアプリケーションのソース コードを見つけることが目的ですが、その設計とアーキテクチャの詳細を見つけることが目的の場合もあります。<span>&nbsp; </span></p>
  <p>次の手順に従って、リバース エンジニアリング バグをテストします。</p>
  <ul>
    <li>手順 1: 攻撃のシナリオを理解する<li>手順 2: 原因と対策を分析する<li>手順 3: テスト ケースを実行する</li></li></li>
  </ul>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <h1>
    <span>手順 1: 攻撃のシナリオを理解する</span>
  </h1>
  <p>最初に、攻撃者がリバース エンジニアリングを利用するシナリオと目的について理解する必要があります。</p>
  <ul>
    <li>ソース コードを見つける<li>ソフトウェアの設計とアーキテクチャを見つける</li></li>
  </ul>
  <p>&nbsp;</p>
  <h2>
    <span>
      <em>シナリオ 1: ソース コードを見つける</em>
    </span>
  </h2>
  <p>リバース エンジニアリングは、バイナリ ファイルや Java クラスなどの中間ファイルから、アプリケーションのソース コードをリカバリするために利用されることがあります。 攻撃者は、これを実行するために、逆アセンブラや逆コンパイラなどのリバース エンジニアリング ツールを利用して、コンパイルまたは構築プロセスを逆方向に行い、ファイルを作成した実際のソース コードを行ごとに再構築する目的で、コンパイルまたは構築されたソース コードを解析します。 攻撃者は、コード リカバリ ツールの出力を入手すると、通常、その出力ソースを利用して、アプリケーションの再構築を試みます。 攻撃者は、この手法を利用して、プログラムのソース コードをリカバリして、目的のタスク (登録/有効化プロセスの排除やセキュリティ チェックの回避など) を実現するためにコードを変更し、攻撃者の意図に合わせてアプリケーションを再構築します。</p>
  <p>詳細: </p>
  <ol>
    <li>攻撃者は、アプリケーションのバイナリ/オブジェクト/クラス ファイルのコピーを入手します。 <li>攻撃者は、ツールを利用して、バイナリ/オブジェクト/クラス ファイルをソース コードに変換します。 <li>攻撃者は、ソース コードを変更して、アプリケーションを再構築します (必要な場合)。</li></li></li>
  </ol>
  <p>最後のステップは、リバース エンジニアリング攻撃において必須項目ではありません。</p>
  <p>&nbsp;</p>
  <h2>
    <span>
      <em>シナリオ 2: ソフトウェアの設計とアーキテクチャを見つける</em>
    </span>
  </h2>
  <p>ソフトウェア アプリケーションは、内部で論理的な決定を行って、対応する環境と相互処理することにより動作します。 たとえば、アプリケーションには、<i>if/then/else</i> または <i>case</i> 条件が複数存在し、さまざまな論理パスが選択できます。 また、大部分のアプリケーションは、適切に動作するために、ハード ディスクからファイルにアクセスして、ネットワークを介して情報を送信し、メモリを消費して、レジストリ (Windows の場合) を利用し、データベースと相互処理する必要があります。 攻撃者は、アプリケーションが論理的な決定を行うタイミングや環境と相互処理する方法を分析することにより、設計が直観的に理解できない場合でも、プログラムの設計を特定することができます。</p>
  <p>このシナリオでは、攻撃者は、逆アセンブラ、逆コンパイラ、デバッガ、依存性チェッカー、監視ツールをなどの一連のツールを利用して、アプリケーションの設計方法とそのアーキテクチャの詳細を見つけ出します。 つまり、アプリケーションが複数の内部パスを決定して、対応する環境と相互処理する方法です。</p>
  <p>詳細: </p>
  <ol>
    <li>攻撃者は、アプリケーションのバイナリ/オブジェクト/クラス ファイルのコピーを入手します。 <li>攻撃者は、依存性チェッカー ツールを使用してアプリケーションを静的に分析し、アプリケーションの分解方法を確認します。 <li>攻撃者は、逆アセンブラを使用してアプリケーションを分析し、さまざまな出力結果に基づいて、異なる論理パスを選択する方法を確認します。 <li>攻撃者は、アプリケーションを実行して、ファイル システム、ネットワーク、データベース、レジストリ、メモリ、サード パーティ製 API とのアクティビティを監視し、環境と相互処理する方法を確認します。 <li>攻撃者は、ステップ 2、3、4 の結果を総合して、アプリケーションの設計とアーキテクチャを特定します。</li></li></li></li></li>
  </ol>
  <p>
    <b>
      <span>&nbsp;</span>
    </b>
  </p>
  <h1>
    <span>ステップ 2: 原因と対応策を分析する</span>
  </h1>
  <p>次のステップでは、実用的なテスト ケースを実行する前に、リバース エンジニアリング バグの原因とその対応策について理解します。</p>
  <p>すべてのエンジニアリング プロセスは逆方向に分析可能であるという前提があるため、リバース エンジニアリング バグは、すべてのソフトウェア アプリケーションに存在します。<span>&nbsp; </span>市販のアプリケーションでは、バイナリやクラス ファイルなどの実行可能ファイルを生成できることが不可欠ですが、これがリバース エンジニアリング攻撃の標的となる場合があります。 また、すべてのソフトウェア アプリケーションは、適切に動作するために、複数の実行パスを追跡して、対応する環境と相互処理する必要があります。これにより、アプリケーションの動作に対してリバース エンジニアリング攻撃を行う機会を与えてしまいます。 リバース エンジニアリング攻撃を防止するためには、開発およびコンパイル/構築プロセスの両方において、アプリケーションに手順を追加する必要があります。</p>
  <h2>
    <em>逆アセンブル対策</em>
  </h2>
  <p>逆アセンブルは、アプリケーションのソース コードを見つけ出すプロセスであり、アプリケーションが実行に使用するバイナリまたはクラス ファイルを解析します。 静的な逆アセンブルを実行して、バイナリまたはクラス ファイルを解析し、ソース コードを再構築するツールには、IDA Pro (さまざまな種類のバイナリ ファイルで使用可能) や Cavaj (Java クラス専用) など、多数のツールがあります。 また、これらのツールの中には、アプリケーションが選択するさまざまな条件や分岐を示すフローチャートなど、アプリケーションの論理的なフローを生成できるものもあります。 逆アセンブルを防止するために、開発者は、逆アセンブル対策の手法を採用することをお勧めします。 逆アセンブル対策に有効な手法の例として、難読化およびコードの暗号化という 2 つの手法があります。</p>
  <p>開発者は、アプリケーションのソース コードを難読化するステップをコンパイル/構築プロセスに追加することにより、アプリケーションに対するリバース エンジニアリング攻撃の影響を軽減できます。<span>&nbsp; </span>難読化は、分岐命令の宛先など、特定の命令を中間関数へのジャンプで置き換えることにより実行します。この際に、分岐命令の宛先がコンピュータで動的に計算されます。またはは、偽の述語を挿入して、非条件分岐をすべて条件分岐に変更します [i]。<span>&nbsp; </span>いずれの手法においても、その主な目的は、アプリケーションのソース コードを逆アセンブラが正しく解釈して、見つけ出すことを防止することです。</p>
  <p>逆アセンブリ対策に関する最近の研究では、コードを暗号化してリバース エンジニアリング攻撃を防止することを提案しています。この場合、マシン コードを暗号化して、実行時に暗号鍵で復号します。 もちろん、リバース エンジニアリング ハッカーは暗号化鍵を持っていません [ii]。<span>&nbsp;&nbsp;&nbsp; </span></p>
  <p>&nbsp;</p>
  <h2>
    <em>デバッグ対策</em>
  </h2>
  <p>デバッグは、実行時にプログラムが追跡する一連の命令を分析するプロセスです。 前に説明したように、デバッグは、実行時のアプリケーションの動作を攻撃者に示すので、リバース エンジニアリング攻撃には非常に役に立ちます。 <span>&nbsp;</span>通常、リバース エンジニアは、<i>SoftIce</i> や <i>WinIce</i> などの、カーネルレベル (または ring-0) でフックできる低位のデバッガを使用します。攻撃者は、<i>ntsd</i>や<i>OllyDbgなどの、ユーザーモードのデバッガを利用する場合もあります。</i></p>
  <p>デバッグにより達成されるリバース エンジニアリング攻撃を防止するために、開発者は、さまざまなデバッグ対策手法を利用できます。たとえば、デバッガの存在をチェックしたり、タイマーやブレイクポイントを挿入したり、アプリケーションに追加されたデバッガを無効にするコマンドを送信したりできます。 この場合、開発者は、実際にチェックを行って、デバッガが発見された際に適切な処置を実行するソース コードをアプリケーションに追加する必要があります。 詳細については、「<em>デバッグ対策とソフトウェア保護に関する助言</em>」を参照してください [iii]。</p>
  <p>
    <span>&nbsp;</span>
  </p>
  <h2>
    <em>その他の対策</em>
  </h2>
  <p>開発者は、セキュリティ対策を追加することにより、リバース エンジニアがアプリケーションの動作を推測するのを困難にすることができます。たとえば、API、関数、実行可能モジュール、ライブラリの名前を、アプリケーションの設計とは関係ない名前に変更します。</p>
  <p>アプリケーションのデバッグ シンボルをアプリケーションに付加しないことも重要です。このシンボルにより、アプリケーションの開発方法に関する重要な情報が開示されてしまうので、リバース エンジニアリングに大きな影響を与えてしまいます。</p>
  <p>最後に、リバース エンジニアリングのリスクが非常に高い場合、開発者とアーキテクトは、アプリケーションに無作為のコンポーネントと動作を挿入して攻撃者を惑わせ、実際はアプリケーションの設計には含まれていないパスを追跡させることを検討する必要があります。 この目的は、アプリケーションのリバース エンジニアリングを非常に困難な作業にして、攻撃者に解析を止めさせることです。 </p>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h1>
    <span>ステップ 3: テスト ケースを実行する</span>
  </h1>
  <p>これで、リバース エンジニアリング バグの理論的な側面のレビューは終了です。次の段階では、実用的なテスト ケースを実行して、アプリケーションをテストする必要があります。</p>
  <h2>
    <span>
      <em>逆アセンブラを使用したリバース エンジニアリングのテスト</em>
    </span>
  </h2>
  <p>次の手順に従って、逆アセンブラでリバース エンジニアリングをテストします。</p>
  <ol>
    <li>IDA Pro をダウンロードして、インストールします (<a href="http://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/IDA-PRO.shtml">http://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/IDA-PRO.shtml</a>)。<li>IDA Pro を実行して、バイナリ ファイルを選択します。 <li>逆アセンブルを開始します。</li></li></li>
  </ol>
  <p>予想される結果:<span>&nbsp; </span>開示してはいけない実装や設計の詳細情報が IDA Pro から推測できた場合、アプリケーションは脆弱であると判断されます。</p>
  <p>
    <b>
      <i>
        <span>&nbsp;</span>
      </i>
    </b>
  </p>
  <h2>
    <span>
      <em>Java 逆コンパイラを使用したリバース エンジニアリングのテスト</em>
    </span>
  </h2>
  <p>次の手順に従って、Java 逆コンパイラでリバース エンジニアリングをテストします。</p>
  <ol>
    <li>Cavaj 逆コンパイラをダウンロードして、インストールします (<a href="http://cavaj-java-decompiler.en.softonic.com/">http://cavaj-java-decompiler.en.softonic.com/</a>)。<li>Cavaj 逆コンパイラを実行します。 <li>メイン メニューで、 [<b>ファイル (File)</b>]-&gt;[<b>開く (Open)</b>] の順にクリックして、標的となる Java クラス ファイルを選択します。</li></li></li>
  </ol>
  <p>予想される結果: 攻撃者に確認されてはいけないソース コードが Cavaj に表示された場合、アプリケーションは脆弱であると判断されます。</p>
  <p>&nbsp;</p>
  <h2>
    <span>
      <em>デバッガを使用したリバース エンジニアリングのテスト</em>
    </span>
  </h2>
  <p>次の手順に従って、デバッガでリバース エンジニアリングをテストします。</p>
  <ol>
    <li>デバッガをダウンロードして、インストールします。 <li>デバッガを実行して、標的となるアプリケーションに組み込みます。 <li>アプリケーションのデバッグを開始します。</li></li></li>
  </ol>
  <p>予想される結果: 開示してはいけない実装または設計の詳細情報がデバッガから推測できた場合、アプリケーションは脆弱であると判断されます。</p>
  <p>
    <b>
      <i>
        <span>&nbsp;</span>
      </i>
    </b>
  </p>
  <h2>
    <span>
      <em>監視ツールを使用したリバース エンジニアリングのテスト</em>
    </span>
  </h2>
  <p>次の手順に従って、監視ツールでリバース エンジニアリングをテストします。</p>
  <ol>
    <li>アプリケーションのバイナリ実行可能ファイルを特定します。 <li>コマンド プロンプトを開きます。 <li>Microsoft<span>&nbsp; </span>Visual Studio のコマンド プロンプト (Visual Studio でインストール済み) において、Windows で <i>dumpbin</i> コマンドを次のように実行します。<span>&nbsp; </span><i>dumpbin -all executable_name &gt; bin_output.txt</i>。実行可能ファイルのすべての依存性、DLL、API の名前の一覧が出力ファイルに表示されます。 <li>アプリケーションを実行します。 <li><i>タスク マネージャー</i> を起動して、アプリケーション プロセスを見つけ、そのアプリケーション プロセスとサブプロセス (サブプロセスを表示するには、<i>プロセス ツリーを表示するためのオプション</i>を選択する必要があります) のプロセス ID 番号を記録します。 <li>コマンド プロンプトで、<i>netstat</i> コマンドを次のように実行します。 <i>netstat -ano &gt; net_output.txt</i><li>アプリケーションが開いた TCP/UDP 接続を調べるために、ステップ 5 のプロセス ID 番号が開いた接続のみを表示するように、net_output.txt ファイルをフィルタリングします。 <li>Process Explorer をダウンロードしてインストールし、実行します (<a href="http://www.sysinternals.com/">www.sysinternals.com</a>)。<li>Wireshark をダウンロードしてインストールし、実行します。 <li>前のステップで得られた情報 (プロセス名、ポート番号など) を使用して、Process Explorer および Wireshark 両方でフィルターをセットアップします。 こうすることにより、ツールで不必要な情報が軽減します。 <li>Process Explorer と Wireshark からの出力を確認して、テスト対象のアプリケーションを使用します。 これらのツールを使用することにより、アプリケーションが、対応する環境 (ファイル システム、レジストリ、カーネル オブジェクト、ネットワーク) と相互処理する方法を詳細に確認することができます。</li></li></li></li></li></li></li></li></li></li></li>
  </ol>
  <p>予想される結果:<span>&nbsp; </span>開示してはいけない実装または設計の詳細情報が検出/監視ツールの出力から推測できた場合、アプリケーションは脆弱であると判断されます。</p>
  <h1>
    <span>結論</span>
  </h1>
  <p>リバース エンジニアリング攻撃は、悪意のあるユーザーに開示してはいけない実装と設計の詳細情報を見つけようと試みます。 リバース エンジニアリング バグをテストするには、さまざまな攻撃シナリオについて理解する必要があります。たとえば、ソフトウェア アプリケーションの動作、設計、アーキテクチャを特定するために、バイナリまたはクラス ファイルを逆方向に解析する処理などです。 すべてのエンジニアリング プロセスは逆方向に解析可能であるため、リバース エンジニアリング攻撃が存在する可能性があります。 ただし、リバース エンジニアリング バグの影響への対応策として、開発者は、逆アセンブリ対策やデバッグ対策の手法を利用できます。 最後に、アプリケーションでこのバグをテストするために、一連の逆アセンブル、デバッグ、検出、監視ツールを使用して、アプリケーション内部の動作に関する詳細を、可能な限り理解しておくことをお勧めします。 結果的に、この作業が攻撃者の行動を理解することになります。<b><span></span></b></p>
  <div>
    <br />
    <hr />
    <div>
      <p>[i] <b>リバース エンジニアリングに対する次世代の防御</b> Chris Coakley, Jay Freeman, Robert Dick.<span>&nbsp; </span>Anacapa Sciences,Inc.)<span>&nbsp; </span><a href="http://www.anacapasciences.com/publications/protecting_software2005.02.09.pdf">http://www.anacapasciences.com/publications/protecting_software2005.02.09.pdf</a></p>
    </div>
    <div>
      <p>[ii]&nbsp;  <b>暗号ハッシュ関数による逆アセンブリ対策 </b>(John Aycock、Rennie deGraaf、Michael Jacobson, Jr.、<span>&nbsp; </span>カルガリー大学)<span>&nbsp; </span><a href="http://pages.cpsc.ucalgary.ca/~aycock/papers/antidis.pdf">http://pages.cpsc.ucalgary.ca/~aycock/papers/antidis.pdf</a></p>
    </div>
    <div>
      <p>[iii] <b>デバッグ対策とソフトウェア保護に関する忠告</b><a href="http://www.woodmann.com/crackz/Tutorials/Protect.htm">http://www.woodmann.com/crackz/Tutorials/Protect.htm</a></p>
      <p>
        <span>&nbsp;</span>
      </p>
      <p>&nbsp;</p>
    </div>
  </div>]]></Data>
  </Content>
</TeamMentor_Article>