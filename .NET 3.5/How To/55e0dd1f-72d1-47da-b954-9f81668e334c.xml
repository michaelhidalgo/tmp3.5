<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1493382218" Content_Hash="1175627213">
  <Metadata>
    <Id>55e0dd1f-72d1-47da-b954-9f81668e334c</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>クロスサイト スクリプティング (XSS) バグをテストする方法</Title>
    <Category>入力とデータの検証</Category>
    <Phase>実装</Phase>
    <Technology>Web アプリケーション</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<BR><BR><H1>適用対象</H1><P>XSS バグは、HTML 入力および出力を操作するアプリケーションに影響を及ぼします。&nbsp; 特に、ASP、ASP、.NET、PHP、PERL、Java、および Visual Basic で開発された Web アプリケーションです。</P><H1>概要</H1><P>クロスサイト スクリプティング (または XSS) は、一般的に XSS に対して脆弱なサーバーを介してインターネット クライアントに影響を及ぼす、周知の HTML 関連のセキュリティの脆弱性です。&nbsp; Web サーバーの XSS バグにより、攻撃者は、脆弱なサーバーを介して IE、Firefox、Netscape などの被害者のブラウザに悪意のあるペイロードを送信します。&nbsp; &nbsp;ペイロードは、HTML を表示して任意の実行文字列を実行していれば、必ずしも Web を閲覧している必要はなく、他の HTTP クライアントで実行することもできます。 </P><P>以下に、XSS バグをテストするのに必要な手順の概要を示します。</P><UL><LI><B>手順 1</B>:&nbsp; XSS 攻撃シナリオを理解する<LI><B>手順 2</B>:&nbsp; ハイリスク コンポーネント<B> </B>および<B> </B>エントリ ポイントを一覧表示する<LI><B>手順 3</B>:&nbsp; テストおよび調査を開始する<LI><B>手順 4</B>:&nbsp; テスト ケース データを調整する</LI></UL><P><B>手順1:&nbsp; XSS 攻撃シナリオを理解する</B></P><P>XSS には反射型と永続型の 2 つのタイプがあります。&nbsp; 反射型 XSS バグは、Web サーバーが訪問者からの入力を受け入れて、入力されたデータに文字列が含まれているかどうかをチェックすることなく訪問者に入力を自動的に返す際に発生します。&nbsp; こうして、入力データは訪問者に反映されて訪問者のブラウザで実行されます。<I></I> &nbsp;</P><P>永続型 XSS バグは、悪意のあるデータに埋め込まれた文字列がデータベース、ファイル、またはその他の保存方法などで永続的に保存される場合です。&nbsp; 文字列が含まれた悪意のあるデータはサーバーに保持されます。<I></I> &nbsp;&nbsp; サーバーのアプリケーションがこの保存されたコンテンツを検証せずにクライアントに送信すると、文字列はブラウザで実行されます。&nbsp;</P><P>両方の XSS 攻撃シナリオを理解して、テストする場合に何に注目すればよいのかを知っておくことが重要です。</P><P><B><I>Web 検索フォーム経由の反射型 XSS シナリオ</I></B></P><P>ある Web サイトには以下のフォームが含まれた search.php という名前の検索ページがあります:</P><P><IMG src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image001.png"></P><P>&lt;form&gt;</P><P>&lt;入力名="searchInput" タイプ="text" サイズ="50"&gt;</P><P>&lt;入力名="searchButton" タイプ="button" サイズ="20" 値="search"&gt;</P><P>&lt;/form&gt;</P><P>&nbsp;searchInput 変数を使用して入力を収集し、同じページに結果を表示します:</P><P>&nbsp;&lt;p&gt; &lt;?php echo $_GET['searchInput']?の検索結果：&gt; are:</P><P>&nbsp;ユーザーがテストを入力すると、以下が表示されます:</P><P><IMG src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image003.png"></P><P>攻撃者は SCRIPT タグを使用して searchInput 変数をエクスプロイトし、以下を入力します:</P><P><IMG src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image005.png"></P><P>サーバーはユーザーに SCRIPT タグが含まれたページを送信し、ユーザーのブラウザはそのコンテンツを実行して XSS のワードでメッセージ ボックスを表示します。&nbsp; 攻撃者は被害者に電子メールを送信して以下の URL をクリックするように伝えます:</P><P>http://teammentorexample.com/search/search.php?searchInput=&lt;SCRIPT&gt;payload&lt;/SCRIPT&gt;</P><P>リンクをたどると、悪意のあるペイロードが被害者のブラウザのコンテキストで実行され、セッションや Cookie の情報を盗んだりするのに使用されます。</P><P><B><I>SQL データベース サーバーを介した永続型 XSS</I></B></P><P>Web アプリケーションは、データベース テーブルにクエリし、そこからプロファイル情報を取得することによって、プロファイル Web ページを作成します。 問題は、データベースがデータベースに保存されている潜在的な文字列を検査しないことにあります。&nbsp; ユーザーのお気に入りの引用文を以下の PHP コードを使用して表示します:</P><P>echo 'favorite quote:&nbsp; &lt;br&gt;';</P><P>$connection = odbc_connect("sqldb", "admin", "root");</P><P>$query = "SELECT quote FROM ProfileTable WHERE UserName = " . &nbsp;$_GET['user']"; </P><P>$result = odbc_exec($connection, $query);</P><P>odbc_fetch_row($result);</P><P>$quote = odbc_result($result, 1); </P><P>print($quote);</P><P>'JohnB' のプロファイル名の攻撃者は、前もってデータベースに接続し、自分のプロファイルにこの情報をお気に入りの引用文として設定します:</P><P>&lt;SCRIPT&gt;alert('XSS') &lt;/SCRIPT&gt;</P><P>これで、このようなリンクをたどって訪問するユーザーには毎回次のようなアラート ボックスが表示されます:</P><P>&nbsp;http://teammentorexample.com/showProfile.php?user=JohnB</P><P>攻撃者は、セッションや Cookie の情報を盗んだりするなど、より危険性の高いペイロードでアラート ボックスを変更することができます。</P><P><B>ステップ 2: リスクの高いコンポーネントとエントリ ポイントのリストを作成する</B></P><P><B><I>ハイリスク コンポーネントを特定する</I></B></P><P>XSS バグをテストする次の手順では、インターネット クライアントから入力データを取得してそれをクライアントに返送するのに使用するコンポーネントを広範かつ慎重に見直します。&nbsp; 大規模の Web サービスの場合、設計や構造などのドキュメントを入手できる場合は、現段階では極めて便利です。 &nbsp;&nbsp;テスト担当者は、Web クライアントにデータを反映 (反映型 XSS) し、後で Web クライアントに送信するためにデータを保存 (永続型 XSS) するコンポーネントについて考慮する必要があります。&nbsp; これを行う一般的なコンポーネントを以下に示します:&nbsp;</P><P>Web ページの検索</P><P>プロファイルに関係する Web ページ</P><P>Web フォーラム</P><P>ブログ</P><P>RSS フィード</P><P>シック クライアントのための HTML ベースのヘルプ ブラウザ&nbsp;</P><P><B><I>HTML レスポンスを書き込むコードを検索する</I></B></P><P>サーバー レスポンスに HTML を追加するスクリプティング関数はさまざまで多数あります。&nbsp; データを書き出すサーバー側のコードを見つけることは、潜在的な XSS 問題を評価して探し出すための最初の手順です。&nbsp; ここにそれを行う関数の例をいくつか示します:</P><P>Response.Write&nbsp;&nbsp;&nbsp; (ASP)</P><P>&lt;%= %&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASP)</P><P>echo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</P><P>print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</P><P>レスポンスにデータを書き込む関数は、テストする言語およびプラットフォームによって異なります。&nbsp; 使用する言語ですべての関連する関数について理解していることを確認してください。</P><P><B><I>レスポンスで未検証およびデコード済みデータをチェックする</I></B></P><P>次に、上記のメカニズムによって何が出力されたのかをチェックする&nbsp; たとえば、アプリケーションは以下を行うことができます:</P><P>Response.Write(Request.QueryString(search))</P><P>URL に検索値のコンテンツを書き込む方法。&nbsp; 変数が文字列に設定されている場合、クライアントが書き込まれたページを表示するとすぐに実行されます。</P><P>以下の PHP コードは、最初はそれほど危険であるように見えません。&nbsp; </P><P>print($quote);</P><P>しかし、上記の持続型シナリオのように、引用変数がデータベースから直接送信された文字列である場合は XSS の影響を受けます。</P><P>出力データがデータベースまたは Web メソッドであってもバックエンドから送信される場合について慎重に調べます。&nbsp; Web メソッドは未検証データを返す場合があります:</P><P>Response.Write(ExternalApplication.GetRSSFeedMethod())</P><P>アプリケーションによって書き込まれたデータが直接ユーザーから送信されてフォーマットについて特別に検証されていない場合でも、適切にエンコードされている場合は、安全である可能性があります。&nbsp; すなわち、エンコーディングには、一般的に試行されるブラックリストではなく、安全であることがわかっている文字 (一般的に英数字のみ) を使用するホワイトリストの形式を採用する必要があります。</P><P><B><I>ハイリスク コンポーネントをエントリ ポイントと一致させる</I></B></P><P>未検証データは Web だけでなく、すべてのアプリケーションのエントリ ポイントから送信されます。&nbsp; クライアントに渡される可能性のある悪意のあるデータのすべての可能性のあるソースが網羅されていることを確認します。&nbsp; 一般的なデータ ソースを以下に示します:</P><UL><LI>Web フォーム<LI>URL の内容<LI>Cookie コンテンツ<LI>Flash パラメータ<LI>SQL データベース クエリ コンテンツ<LI>Web サービス データ<LI>グラフィカル ユーザー インターフェイス</LI></UL><P>アプリケーションおよびデータ ソースのハイリスク変数を一覧表示し、レビューおよびテストの間それらが網羅されているかを確認する&nbsp;&nbsp;</P><P><IMG src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image007.png"></P><P><B>手順 3:&nbsp; テストおよび調査を開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B></P><P>この手順では、基本的な XSS ファズ文字列を送信してアプリケーションの反応を観察し、バグの存在を示す簡単なアラート ボックスを表示するテストを行います。</P><P><B><I>簡単なファズ文字列で開始する</I></B></P><P>XSS バグの検出に成功するには、テスターが HTML 文字列をサーバーにまたはサーバーを介して保存または反映できるかどうかによります。&nbsp; ほとんどすべてのケースで文字列は SCRIPT タグの間に含まれています (後で説明しますが他のタグでも機能します)。&nbsp; この手順では、サーバー アプリケーションのハイリスク コンポーネントがタグ関連の入力にどのように反応するか、調査を始めることを推奨します。&nbsp; テストを開始するにあたって、以下のような簡単なファズ文字列を使用すると便利です:</P><P>'&gt;;!--"&gt;&lt;XYZ&gt;&lt;=&amp;{()}</P><P>次に、サーバーのレスポンスで文字列 XYZ を探し出し、サーバーが特定の文字列に関係のある文字をどのように処理したのかを調べます。&nbsp; サーバーがタグの内側で文字列を使用していることが判明する場合があります:</P><P>&lt;<B>input</B> type="text" name="keyword" id="keyword" maxlength="255" value="'&gt;;!--"&gt;&lt;<A name=line163></A><B>XYZ</B>&gt;&lt;=&amp;{()}" style="height:10px; color:#000;" /&gt;</P><P>最初の文字列を変更することによって、アラートを表示できるようにします。&nbsp; 元のファズ文字列の二重引用符が<I>値</I>のプロパティを囲んでいるため、その前に何が配置されていても関係ありません。&nbsp; また、文字 Z の横にある閉じ丸括弧の後ろの文字列は任意の文字列です。&nbsp; 文字列の取得は次のように簡易化することができます:</P><P>"&gt;&lt;XYZ&gt;</P><P>サーバーの応答は以下のようになります:</P><P>&lt;<B>input</B> type="text" name="keyword" id="keyword" maxlength="255" value=""&gt;&lt;<A name=line1631></A><B>XYZ</B>&gt;" style="height:10px; color:#000;" /&gt;</P><P>詳細については、&nbsp;&nbsp;Ha.ckers.com (<A href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</A>) の XSS チート シートを参照してください。</P><P><B><I>アラート ボックスが表示されるように試行する</I></B></P><P>以下の目的は文字列を実行することで、テストのための最も簡単な文字列は、最初のシナリオで表示したアラート ボックスが表示される文字列です。&nbsp; これで、テスターは悪意のある文字列が HTML ドキュメントに表示されるようにするには "&gt; 文字を使用して開始する必要があることを理解しました。</P><P>"&gt;&lt;script&gt;alert('Works')&lt;/script&gt;</P><P>サーバーが SCRIPT タグをフィルタリングしないと、アラート ボックスが表示されます。&nbsp; テスターに送り返されるコードは次のようになります。</P><P>&lt;<B>input</B> type="text" name="keyword" id="keyword" maxlength="255" value=""&gt;<A name=line16311></A><U>&lt;script&gt;alert('Works')&lt;/script&gt;</U>" style="height:10px; color:#000;" /&gt;</P><P><B><I>さまざまなタグを網羅する</I></B></P><P>時にはサーバーが文字列 &lt;script&gt; を出力から除外する場合があります。&nbsp; サーバーがスクリプト タグを許可しない場合は、img タグを試行してコードを src プロパティに配置します:</P><P>"&gt;&lt;img src="javascript:alert('Works');"&lt;/img&gt;</P><P>実際に、&lt;iframe&gt;、&lt;body&gt;、&lt;embed&gt;、&lt;meta&gt;、&lt;html&gt;、&lt;frame&gt;、&lt;frameset&gt;、&lt;input&gt;、&lt;layer&gt;、&lt;object&gt;, および &lt;style&gt; など、その他にも危険性のあるタグは多数あります。 </P><P>スクリプト タグや JavaScript コマンドを必要としない次のようなものを試してみることをお勧めします:</P><P>"&gt;&lt;body onload=alert('Works')&gt;</P><P><B>手順 4:&nbsp; テスト ケース データを調整する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B></P><P>この手順では、すべてのエントリ ポイントを網羅し、特定のエントリ ポイントのフォーマットに基づいてテスト ケース データを調整するテストを行います。&nbsp;&nbsp; </P><P><B><I>エントリ ポイントに応じて文字列のフォーマットとエンコーディングを考慮する</I></B></P><P>手順 3 の例では、ファズ文字列をアプリケーションに渡した方法を指定していません (この場合は Web フォームから渡されたと推測することができます)。 &nbsp;この手順では、テスターはコンポーネントとエントリ ポイントのリストを調べて、エントリ ポイントに応じてテスト ケース データを変更する必要があります。&nbsp; すべてのエントリ ポイントが網羅されていることを確認してください。</P><P><B><I>Web フォーム</I></B></P><P>Web フォームは一般的に ASCII 文字列のみを許可するため、最も簡単にテストすることができます。&nbsp; このエントリ ポイント全体をテストするには、ハイリスク コンポーネント リストを調べて Web フォームがあるコンポーネントを探します。&nbsp; 次に、Web ブラウザを使用してフォーム経由でコンポーネントにテスト文字列を送信し、可能な場合は Burp Suite のような攻撃プロキシを使用してデータ検証に使用するクライアント側 JavaScript を回避します。</P><P><B><I>URL コンテンツ</I></B></P><P>Web アプリケーションは、パスワード変数で渡された値を経由する XSS に対して脆弱です:&nbsp;</P><P>http://www.xvulnerablesite.com/login.asp?username=[value]&amp;password=[value]</P><P>テスターが以下の文字列をテストする場合:&nbsp;</P><P>&lt;script&gt;alert('Works')&lt;/script&gt;</P><P>上記の URL を次のように変更する必要があります:</P><P>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;script&gt;alert('Works')&lt;/script&gt;</P><P>URL 経由でテスト ケースを実行する場合は、テスト文字列のさまざまなエンコーディングを試行することが重要です。&nbsp;&nbsp; たとえば、以下の最初の攻撃文字列を実行しても何ら影響が認められません。&nbsp; 次に、2 番目の文字列を実行すると、アラート ボックスが機能します。&nbsp; この場合、Web アプリケーションでは ASCII の記号文字 (丸括弧を除く) は許可されませんでしたが、16 進数のエンコーディングは許可されました:&nbsp;</P><P>&lt;img src="javascript:alert('Works');"&gt;</P><P>&nbsp;http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img%20src%3d%22javascript:alert(%27Works%27)%22&gt;</P><P>URL 経由またはその他の場所でテストする場合は、サーバーが使用しているエンコーディングのタイプを調査し、それに応じてテスト ケースを変更する必要があります。</P><P><B><I>Cookie コンテンツ</I></B></P><P>アプリケーションは時々盲目的に、Web ブラウザに以下の PHP コードに表示されているような Cookie のコンテンツを表示する場合があります:</P><P>&lt;?php&nbsp; echo $_COOKIE["testcookie"]; ?&gt;</P><P>このエントリ ポイントから危険性の高いコンポーネントをテストするには、ディスクの Cookie ファイルを変更して単純なスクリプトを挿入する必要があります。</P><P><IMG src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image009.png"></P><P>次に、ブラウザを再開始して PHP コードが含まれているページに移動し、アラート ボックスが表示されるか確認します。&nbsp; または、攻撃プロキシを使用してこの変更をオンザフライで実行することもできます。これは複雑なアンプリケーションの場合に特に役立ちます。</P><P><B><I>Flash パラメータ</I></B></P><P>Flash パラメータは URL で頻繁に渡されるため、Flash パラメータをテストすることは、URL のコンテンツをテストすることと同じです。&nbsp; ここでは、URL の各パラメータを調べてアプリケーションの反応を観察する必要があります。&nbsp; Flash もまた、<B>FlashVars</B> を使用して頻繁にパラメータを受け取ります。&nbsp;以下のコードを考慮して Flash ムービーを読み込みます:</P><P>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</P><P>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</P><P>&nbsp;width="250" height="250" id="flaMovie1" align="center"&gt;</P><P>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</P><P>&nbsp;&lt;param name=<B>FlashVars</B> value=<B>"inputURL=usersinput"</B>&gt; </P><P>&nbsp;&lt;param name=quality value=high&gt; </P><P>&nbsp;&lt;param name=bgcolor value=#ffffff&gt;</P><P>&nbsp;&lt;embed src="flaMovie1.swf" <B>FlashVars</B>=<B>"inputURL=usersinput"</B> </P><P>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250"</P><P>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash"</P><P>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</P><P>&lt;/object&gt;</P><P>&nbsp;この手順では、テスターは Flash のエントリ パラメータを以下のように変更する必要があります:</P><P>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</P><P>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</P><P>&nbsp;width="250" height="250" id="flaMovie1" align="CENTER"&gt;</P><P>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</P><P>&nbsp;&lt;param name=<B>FlashVars</B> value=<B>"inputURL=%3cscript%3ealart%28%b4XSS%b4%29%3c%2fscript%3e"</B>&gt; </P><P>&nbsp;&lt;param name=quality value=high&gt; </P><P>&nbsp;&lt;para name=bgcolor value=#ffffff&gt; </P><P>&nbsp;&lt;embed src="flaMovie1.swf" <B>FlashVars</B>=<B>"inputURL=%3CSCRIPT%3Ealert%28%B4XSS%B4%29%3C%2FSCRIPT%3E"</B> </P><P>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250"</P><P>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash"</P><P>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</P><P>&lt;/object&gt;</P><P><B><I>グラフィカル ユーザー インターフェイス</I></B></P><P>UI 経由によるテストは、テスターがテスト値&nbsp; を画面に直接入力するという点で、Web フォーム テストと同じです。&nbsp; GUI テストの場合、使用されるアプリケーションは Web ブラウザではなく、その他のアプリケーションです。これは、ハイリスク コンポーネントと相互作用し、HTML&nbsp; を表示し、ユーザー入力を許可するかまたはそうでない場合は信頼されていないデータを受信します。<B></B></P><P><B><I>追加のエントリ ポイントを調べる</I></B></P><P>各アプリケーションにはエントリ ポイントの固有のセットがあります。&nbsp; この項では、XSS 攻撃の一般的なものをリストに表示します。&nbsp; しかし、テスターはデータを渡す他の方法で XSS 脆弱性を招く恐れがないかアプリケーションを調査する必要があります。&nbsp; 妨害して一致したら置換ルールを追加して HTTP パケットのコンテンツを変更することができる www.sysinternals.com からのシステム監視ツールや Burp プロキシなどの専用の攻撃ツールを使用することをお勧めします。</P><P><B><I>テスト ケースの調整を続ける</I></B></P><P>初期のテスト文字列ではソース コードの一部に配置される場合があり、スクリプト タグを使用せずに XSS が可能になります。&nbsp; テスターは少しだけ埋めるか、JavaScript コマンドを書き込むだけになる場合があります。&nbsp; 初期入力が実際のコマンドまたはパラメータの内側または内部に配置されたかどうかを常にチェックしてください。</P><P>スクリプトを挿入するためのタグの変更には、さまざまな方法があります。&nbsp; クロスサイト スクリプティング脆弱性に対する Web アプリケーションのテストの詳細については、<A href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</A>&nbsp;および&nbsp; <A href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</A> を参照してください。</P><P><B><I>持続型 XSS のケースを考慮する</I></B></P><P>テスターがテスト ケースの結果をすぐに確認できない場合があります。&nbsp; 攻撃者が別のページを訪問するなど、他の動作を行った場合にのみ受信した悪意のある入力を送り返す XSS バグが存在する場合があります。&nbsp; これは、持続型 XSS 攻撃によくあるケースです。</P><P>以下のケースについて考慮します。&nbsp; アプリケーションがユーザーのパスワードのヒントを尋ねます。&nbsp; サーバーがユーザーにヒントを入力するようにプロンプトを表示すると、攻撃者は以前説明した XSS テスト文字列の 1 つを入力します。&nbsp; 次に登録を送信しますが、サーバーはアラート ボックスを表示しません。&nbsp; 次に、攻撃者は被害者にサイトのパスワード ページを参照させてヒントを尋ねます。&nbsp; サイトがヒントを表示すると、アラート ボックスが表示されます。&nbsp; </P><P>持続型 XSS をテストする際には、テスターは入力される可能性のあるすべての場所について考慮し、チェックする必要があります。&nbsp; テスターは開発者に伝えて仕様書を使用し、持続型 XSS バグが出現する可能性のあるすべてのデータ ストアをチェックする必要があります。</P><P><B><I>テスト ケースを自動化する</I></B></P><P>成功した XSS 攻撃を収集するサーバーを設定することによって XSS テストを自動化することができます。&nbsp; たとえば、以下のコードを保有する ASP ページを作成してページに results.asp という名前を付けます。</P><P>&lt;%<BR>&nbsp;&nbsp; set fso = Server.CreateObject("Scripting.FileSystemObject")<BR>&nbsp;&nbsp; set fw = fso.CreateTextFile("c:\inetpub\wwwroot\results.txt",True)<BR>&nbsp;&nbsp; fw.WriteLine("test case:")<BR>&nbsp;&nbsp; fw.WriteLine(Request.QueryString("testcase"))&nbsp;&nbsp; <BR>&nbsp;&nbsp; fw.Close <BR>%&gt;</P><P>&nbsp;次に、変更するか、または新しい HTTP リクエストを作成することによってターゲット サーバーにテスト ケースを生成します。&nbsp; アラートを表示する代わりに、スクリプトは対応するテスト ケース番号を渡すことによって results.asp を呼び出します (HTML タグの src プロパティを使用)。&nbsp; たとえば、テスターがログイン ページのパスワード フィールドで img タグを使用して XSS を網羅するとします。&nbsp; このテスト ケースに 17 のラベルを付けます。&nbsp; 次に自動化を使用して以下の文字列を渡します:</P><P>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img src="http://xyoursite.com/results.asp?testcase=17"&gt;</P><P>&nbsp;このテスト ケースが失敗した場合、17の値がファイルに表示され、テスターは XSS バグの検出とその原因を知ることができます。&nbsp; テスターは何百ものこのようなテスト ケースをコード化して HTTP クライアントなどで自動的にテストを生成することができます。&nbsp;</P><P>さらに、<A href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</A> では無料で入手できるさまざまなファズを参照することができます。&nbsp; これらのほとんどは XSS テストを実行する機能があり、脆弱性を発見することができます。</P><H1>結論</H1><P>XSS バグのテストは複雑ではありませんが、徹底的に行う必要があります。&nbsp; Web サーバーが HTML 出力を表示するすべての場所を調べることが重要です。&nbsp; 試行する文字列は多数あり、調べるタグも多数あり、テスト データの入力方法にもさまざまな方法がある上に、自動化の余地もあります。&nbsp; しかし、留意すべき最も重要なことはテスト データに従うということです。&nbsp; アラート ボックスをただ見るだけではなく、背後にあるコードを観察してください。&nbsp; テスト ケース データを調整する方法を知ることができれば、XSS テストは成功したと言えます。</P><H1>追加資料&nbsp;</H1><UL><LI>XSS (クロスサイト スクリプティング) チート シート。&nbsp; Ha.ckers.com (<A href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</A>)<LI>クロスサイト スクリプティング脆弱性に対して Web アプリケーションをテストする、クリス ウェーバー <A href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</A>&nbsp;<LI>OWASP Testing Guide Appendix C: Fuzz Vectors:  <A href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</A><LI>&nbsp;ファズ テスト。&nbsp; Wikipedia <A href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</A>&nbsp;</LI></UL><H1>関連する項目</H1><DIV><UL><LI><DIV>&nbsp;<A href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">攻撃: クロス サイト スクリプティング攻撃</A></DIV></LI></UL></DIV>]]></Data>
  </Content>
</TeamMentor_Article>