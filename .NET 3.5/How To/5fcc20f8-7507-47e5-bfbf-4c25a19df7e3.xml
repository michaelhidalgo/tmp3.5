<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-1481885054" Content_Hash="-14696488">
  <Metadata>
    <Id>5fcc20f8-7507-47e5-bfbf-4c25a19df7e3</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>おびき寄せ (Luring) バグのテスト方法</Title>
    <Category>特権の昇格</Category>
    <Phase>テスト</Phase>
    <Technology> 任意</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>適用対象</h1>
  <ul>
    <li>すべてのソフトウェア アプリケーション</li>
  </ul>
  <p>&nbsp;</p>
  <h1>概要</h1>
  <p>異なる特権で実行される複数のコンポーネントから構成されているソフトウェア アプリケーションは、おびき寄せによる攻撃 (Luring Attack) に対して脆弱です。 この攻撃は、アプリケーションを操作して、攻撃者の代わりに特権アクションを実行させます。 通常、攻撃者は、特権の低いコンポーネントを使用して特権の高いコンポーネントをおびき寄せ、悪意のある命令を実行させます。 そのため、この攻撃は、特権の昇格が行われる 1 つのケースです。</p>
  <p>次の手順に従って、おびき寄せ (Luring) バグをテストします。</p>
  <ul>
    <li>手順 1: 攻撃のシナリオを理解する<li>手順 2: 原因と対策を分析する<li>手順 3: テストと調査を開始する</li></li></li>
  </ul>
  <p>&nbsp;</p>
  <h1>手順 1: 攻撃のシナリオを理解する</h1>
  <p>おびき寄せ (Luring) バグのテスト方法を把握するための最初のステップは、さまざまな種類のおびき寄せによる攻撃 (Luring Attack) シナリオについて理解することです。</p>
  <ul>
    <li>定期タスクの委任をエクスプロイトする<li>偽装をエクスプロイトする</li></li>
  </ul>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h2>
    <em>シナリオ 1: 定期タスクの委任をエクスプロイトする</em>
  </h2>
  <p>多くのソフトウェア アプリケーションにおいては、アプリケーションの個々のコンポーネントによって後で実行されるように定期タスクを作成することができます。 個々のコンポーネントがより高い特権でタスクを実行する場合があり、これがおびき寄せによる攻撃 (Luring Attack) の可能性を高めます。 &nbsp;このシナリオでは、攻撃者は、通常自分が持っている特権より高い特権でアプリケーションにタスクを実行させる目的で、定期タスク機能を使用します。&nbsp; </p>
  <p>Microsoft SQL Server に影響を与えるおびき寄せ (Luring) シナリオの良い例が、2002 年に David Litchfield により発見されました [i]。 SQL Server は、一部の設定において 2 つの別のプロセスを実行します。つまり、実際のデータベース サーバのプロセスと、SQL Server エージェントのプロセスです。 この問題の原因は、SQL Server エージェントが実行するタスクの挿入に利用できる、<i>xp_runwebtask</i> と呼ばれる拡張プロシージャにリモート ユーザーがアクセスできたということです。 攻撃者は、低い特権でこのストアド プロシージャを実行して、実行するのに高い特権を必要とする悪意のあるタスクをセットアップすることができました。その後、エージェントがタスクを選択して実行するのを待っていました。 Symantec LiveUpdate クライアントに影響を与える同様のバグが、2004 年の後半に発見されました。 このバグでは、特権の低いクライアントが LiveUpdate GUI を使用して定期タスクをセットアップすることを許可してしまいました。 後に、LiveUpdate エージェントが、悪意を持ってセットアップされたタスクを高い特権で実行し、その結果、おびき寄せによる攻撃 (Luring Attack) が行われました [ii]。</p>
  <h2>
    <em>シナリオ 2: 偽装をエクスプロイトする</em>
  </h2>
  <p>ソフトウェア アプリケーションは、特権による Attack Surface (攻撃対象領域) を軽減させるために低い特権で実行され、特定のタスクを実行するときにのみ高い特権を持つアカウントを偽装し、最終的にまた特権を低くします。 このシナリオでは、攻撃者は、アプリケーションを操作して、アプリケーションが高い特権を持つアカウントを偽装している際に、特定のタスクを実行させます。</p>
  <p>&nbsp;</p>
  <h1>手順 2: 原因と対策を分析する</h1>
  <p>次に、テスト ケースを実行する前には、おびき寄せ (Luring) バグの原因とその防御方法について理解する必要があります。&nbsp; </p>
  <h2>
    <em>定期タスク</em>
  </h2>
  <p>大部分の場合、実装が不適切であるというより、選択した設計が安全でないということが原因で、アプリケーションがおびき寄せによる攻撃 (Luring Attack) に対して脆弱になります。 具体的には、アプリケーションに脆弱性があると、アプリケーションが後で実行する命令または定期タスクを、特権の低いコードがセットアップすることを許可してしまいます。 たとえば、上記の SQL Server と Symantec のシナリオが発生した原因は、実際のタスクが高い特権を持つアカウントで実行される際に、アプリケーションが、特権の低いユーザーにタスクの構成を許可してしまったということです。 これを防止するには、アーキテクトと開発者が、アプリケーションに実装されている委任およびタスクのスケジューリング機能を調べて、高い特権を持つアカウントのみが、高い特権で実行されるタスクを作成できるように制限する必要があります。</p>
  <h2>
    <em>偽装</em>
  </h2>
  <p>おびき寄せによる攻撃 (Luring Attack) のもう 1 つの一般的な原因として、アプリケーションが高い特権を持つアカウントを偽装して、低い特権で実行されていた際に作成された命令やタスクを実行するということです。これにより、特権の低いユーザーがタスクを作成することを許可してしまいます。 この攻撃を防止するには、開発者が、アプリケーションの設計と実装を修正して、高い特権を持つアカウントを偽装している際に実行される命令の作成と変更を、特権の低いユーザーには許可しないことが必要になります。</p>
  <h2>
    <em>Microsoft .NET アプリケーション</em>
  </h2>
  <p>Microsoft .NET アプリケーションは、異なるアセンブリを 1 つのプロセスに統合することにより動作します。各アセンブリには、独自の特権レベルとアクセス許可が指定されています。 たとえば、一部のアセンブリは、「部分的に信頼されているアセンブリ」などの最低限の特権で動作し、システム リソースへのアクセスが制限されている場合があります。一方、「完全に信頼されているアセンブリ」などの高い特権を持ち、システム リソースへのアクセスが制限されていないアセンブリもあります。 &nbsp;Net Frameworkでは、暗黙的な LinkDemand を利用して、信頼されていないアセンブリからのおびき寄せによる攻撃 (Luring Attack) を防止します。この <i>LinkDemand </i>は、アセンブリで特権コマンドを実行する前にスタックを調べて、スタック内のすべてのアセンブリに適切なアクセス許可が付与されていることをチェックします。 このため、攻撃者が、リモート サイトでホスティングされている悪意のある、信頼されていないアセンブリを使用して、標的となるクライアントのローカル マシンにインストールされた完全に信頼されているアセンブリを呼び出して特権アクションを実行する場合は、ランタイムがスタックをチェックして、呼び出し元が信頼されていないことを判別し、セキュリティ例外をスローして標的を保護します。 </p>
  <p>暗黙的な要求に関する問題は、開発者が、実際には完全な信頼性を与えず、部分的に信頼されているアセンブリに対して、完全に信頼されているアセンブリの呼び出しを許可する必要があったため、展開上の問題を引き起こしてしまったということです。 この問題のソリューションは、Microsoft .NET Framework 1.1 のリリースにおいて、<i>AllowPartiallyTrustedCallers</i> (APTCA) と呼ばれるアセンブリ属性の形式で提供されています。 この属性を利用することにより、完全に信頼されているアセンブリが、セキュリティ例外をスローせずに、部分的に信頼されている呼び出し元にそのアセンブリを利用させることが可能になっています。</p>
  <p>ただし、APTCA は展開上の問題に対応していますが、適切に使用されていない場合は、.NET 環境で再度おびき寄せによる攻撃 (Luring Attack) を引き起こしてしまいます。 開発者が、アセンブリでコードを変更せずに APTCA を使用している場合は、Attack Surface (攻撃対象領域) が広がり、おびき寄せによる攻撃 (Luring Attack) が発生する可能性が高くなります。 このシナリオから防御するために、開発者が APTCA を使用する場合は、追加のセキュリティ対策として、高い特権を持つ命令の前に明示的な <i>Demands</i> を利用する必要があります。 これにより、開発者は、信頼されているアセンブリを APTCA としてマーキングし、信頼されていないアセンブリが、おびき寄せによる攻撃 (Luring Attack) を実行するのを防止できます。 [iii]&nbsp;</p>
  <p>&nbsp;</p>
  <h1>手順 3: テストと調査を開始する</h1>
  <p>これで、おびき寄せによる攻撃 (Luring Attack) の理論的な側面についての説明はすべて終了です。次の段階では、テスト ケースを実行して、現在のアプリケーションでこの攻撃をテストする必要があります。</p>
  <h2>
    <em>定期タスクの保管場所を変更することによるおびき寄せ (Luring) のテスト (ローカル テスト)</em>
  </h2>
  <p>次の手順に従って、定期タスクによりおびき寄せ (Luring) をテストします。</p>
  <ol>
    <li>特権の高いユーザーとしてシステムにログインします。<li>アプリケーションを監視して、定期タスクの保管場所を特定します。 このステップでは、Process Monitor (<a href="http://www.sysinternals.com/">www.sysinternals.com</a>) などの、ファイル システム/レジストリ監視ツールを利用できます。<li>定期タスクの保管場所に対するアクセス権をチェックします。 特権の低いユーザーに対してアクセスが許可されている場合は、ステップ 3 に進みます。 特権の高いユーザーにアクセスが限定されている場合は、テスト ケースを終了します。<li>特権の高いアカウントからログアウトして、特権の低いユーザーで再度ログインします。<li>保管場所 (ファイル、レジストリ、データベース テーブルなど) を直接変更することにより、定期タスクを作成します。<li>アプリケーションがタスクを選択して、実行するのを待ちます。</li></li></li></li></li></li>
  </ol>
  <p>予想される結果: ステップ 5 で作成したタスクが実行された場合、このアプリケーションは脆弱であると判断されます。</p>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h2>
    <em>タスクをスケジュールするアプリケーションの機能によるおびき寄せ (Luring) のテスト (ローカル テスト)</em>
  </h2>
  <p>次の手順に従って、定期タスクによりおびき寄せ (Luring) をテストします。</p>
  <ol>
    <li>特権の低いユーザーとしてシステムにログインします。<li>アプリケーションを監視して、アプリケーションが定期タスクを保管するタイミングと場所を特定します。 このステップでは、Process Monitor (<a href="http://www.sysinternals.com/">www.sysinternals.com</a>) などの、ファイル システム/レジストリ監視ツールを利用できます。このステップでの目的は、特権の低いユーザーがタスクを作成することを許可している、アプリケーションの機能を見つけることです (前に説明した、SQL Server エージェントと LiveUpdate のシナリオの場合と同様です)。<li>このアプリケーション機能を使用して、タスクを作成します。 定期タスクを作成することができた場合は、ステップ 4 に進みます。 &nbsp;定期タスクを作成できなかった場合は、テスト ケースを終了します。<li>アプリケーションが、ステップ 1 で使用した特権より高い特権でタスクを選択して、実行するのを待ちます。</li></li></li></li>
  </ol>
  <p>予想される結果: ステップ 3 で作成したタスクがより高い特権で実行された場合、このアプリケーションは脆弱であると判断されます。</p>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h2>
    <em>偽装によるおびき寄せ (Luring) のテスト (ローカル テスト)</em>
  </h2>
  <p>次の手順に従って、偽装によるおびき寄せ (Luring) をテストします。</p>
  <ol>
    <li>特権の高いユーザーとしてシステムにログインします。<li>テスト対象のアプリケーションのデバッグを開始して、すべての偽装 API にブレイクポイントを設定します。<li>このアプリケーションを使用して、特権の高いアカウントを偽装しているかどうかを確認します。 偽装している場合は、デバッガに割り込んできます。 デバッガに割り込んでこない場合は、テスト ケースを終了します。<li>特権の高いアカウントの偽装時に実行されるコマンドがあるかどうかをチェックします。 このようなコマンドが存在する場合は、ステップ 5 に進みます。 このようなコマンドが存在しない場合は、テスト ケースを終了します。<li>ステップ 4 で見つかったコマンドを変更して、より高い特権で実行されるかどうかを確認します。</li></li></li></li></li>
  </ol>
  <p>予想される結果: ステップ 5 で変更した特権コマンドが実行された場合、このアプリケーションは脆弱であると判断されます。</p>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h2>
    <em>リモート アセンブリからのおびき寄せ (Luring) のテスト (Microsoft .NET テスト)</em>
  </h2>
  <p>次の手順に従って、リモート サイトでホスティングされているアセンブリからのおびき寄せ (Luring) をテストします。</p>
  <ol>
    <li>特権の高いアクションを実行しているローカル アセンブリを見つけます。<li>ローカル アセンブリを呼び出して、特権の高いアクションを実行する関数を呼び出す、ASP .NET ページ/アセンブリを作成します。<li>ステップ 2 で作成したページをホスティングする悪意のあるサイトを作成します。<li>標的となるマシンにログインします。<li>ブラウザーを開き、ステップ 3 で作成したページにアクセスします。 &nbsp;</li></li></li></li></li>
  </ol>
  <p>予想される結果: ステップ 2 で呼び出した特権アクションが実行された場合、このアプリケーションは脆弱であると判断されます。</p>
  <p>&nbsp;</p>
  <h1>結論</h1>
  <p>おびき寄せによる攻撃 (Luring Attack) とは、特権の低いアカウントで脆弱なアプリケーションをおびき寄せ、特権の高いアクションを実行させることです。 この場合の 注目すべき 2 つのシナリオは、定期タスクの委任をエクスプロイトするシナリオ、および特権の高い .NET クラス/アセンブリをリモートで呼び出すシナリオです。&nbsp; これらのバグは主に、設計内容が安全でない場合に発生します。たとえば、安全でない場所にタスクを保管したり、特権の低いユーザーが、特権の高いコンポーネントにデリゲートされるタスクを作成することを許可したりすることです。 .NET では、これらのバグは、アセンブリのマーキングが不適切である場合に発生します。アセンブリのマーキングが不適切であると、適切なセキュリティ対策が行われずに、部分的に信頼されているコードがこのようなアセンブリを呼び出すことを許可してしまいます。&nbsp; </p>
  <p>おびき寄せバグは、次の手順でテストします。1) プログラムと対応する環境 (ファイル システム、レジストリ、データベース サーバなど) の対話状況を調査して、タスクがデリゲートされて保管される仕組みを調べます。 2) 偽装時に、テスト対象のアプリケーションがタスクを実行する方法を調べます。 3) 特権の低いアカウントを使用して、より高い特権で実行されるタスクをすべて変更します。 .NET シナリオをテストする場合は、完全に信頼されているアセンブリを呼び出す ASP アプリケーションを作成して、そのアプリケーションをおびき寄せ、通常よりも高い特権でコードを実行させます。</p>
  <p />&nbsp;<br /><hr /><p /><div><div><p>[i] <strong>Microsoft SQL が特権の昇格を許可する</strong> &nbsp; (Secunia)。 <a href="http://secunia.com/advisories/7325/">http://secunia.com/advisories/7325/</a>&nbsp;</p></div><div><p>[ii] <b>Symantec Windows LiveUpdate NetDetect の特権の昇格</b>(Secunia)。 &nbsp;<a href="http://secunia.com/advisories/13445/">http://secunia.com/advisories/13445/</a></p><p /></div><div><p>[iii]&nbsp;<b>APTCA の使用</b>  MSDN ブログ - 「A Bull’s View of Life and Technology」&nbsp; <a href="http://blogs.msdn.com/ashishme/archive/2006/06/09/623840.aspx">http://blogs.msdn.com/ashishme/archive/2006/06/09/623840.aspx</a></p><p>&nbsp;</p></div></div>]]></Data>
  </Content>
</TeamMentor_Article>