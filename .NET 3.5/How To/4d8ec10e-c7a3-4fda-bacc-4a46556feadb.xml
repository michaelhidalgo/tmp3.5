<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1330177165" Content_Hash="1965794950">
  <Metadata>
    <Id>4d8ec10e-c7a3-4fda-bacc-4a46556feadb</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>ASP.NET 内に例外情報漏えいバグがないかどうかテストする方法</Title>
    <Category>情報漏えい</Category>
    <Phase>テスト</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>その方法</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<H1><SPAN>概要</SPAN></H1><P>開発者にとって、エラーメッセージに記された情報は、アプリケーションで障害が発生した原因およびエラーの修復対策に役立ちます。 しかし、この情報が、間違って他者の手に渡ると悪用される恐れがあります。 多くの場合、攻撃者は、例外やエラー メッセージによる情報を利用して攻撃を仕掛けてきます。 </P><P>以下の手順に従って、例外情報漏えいバグをテストします。</P><UL><LI>手順 1: 攻撃のシナリオを理解する<LI>手順 2: 原因と対策を分析する<LI>手順 3: テストと調査を開始する<LI>手順 4: 追加テストを実行する</LI></UL><P>&nbsp;</P><H1><SPAN>手順 1: 攻撃のシナリオを理解する</SPAN></H1><P>最初のステップでは、ASP.NET における一般的な例外情報漏えい攻撃シナリオを三つ確認していきます。</P><OL><LI>リスクの高い攻撃の実行 <LI>ソース コードの公開 <LI>アプリケーションの内部動作の発見 </LI></OL><H2><EM>リスクの高い攻撃の実行</EM> </H2><P>一般的な例外情報漏えいシナリオでは、通常は不可能な SQL インジェクションなどのリスクの高い攻撃を攻撃者が実行できます。 たとえば、攻撃者は、標的のデータベースにクエリーおよび変更を起こす SQL インジェクション攻撃を実行するため、テーブル名およびコラム名といった、データベース ストラクチャを見つけ出す必要があります。 攻撃者は、不正な形式のインプットを送りつけ、さらにアプリケーションで障害を発生させることで、例外からのデータベース情報を収集し、次に適切な攻撃文字列を構築します。</P><P>たとえば、ASP.NET ウェブ アプリケーションは、二つのテキストボックスを持ったウェブ フォームを使ってログインしたとします。 すると、攻撃者は、次の値をウェブ フォームにサブミットすることで SQL インジェクションのテストを開始します。</P><pre><SPAN>Username: a' OR 1=1<SPAN></SPAN></SPAN></pre><pre><SPAN>Password: abc</SPAN></pre><P>アプリケーションは、図 1 に示されるようにエラー メッセージを返します。</P><P>&lt;&lt;図&nbsp;1 をここに挿入する&gt;&gt;&nbsp;</P><P><B><SPAN>図 1 – SQL Server データベースを公開する ASP .NET エラー メッセージ</SPAN></B></P><P>攻撃者は、SQL 例外によって、バックエンド ストレージが SQL Server データベースによって構成されること、またテーブルにコラム名を持つ <I>パスワード</I> が含まれることを知ります。また、例外は、SQL インジェクションが可能であることを明確に示します。なぜなら、攻撃者がサブミットした危険な文字列は、SQL ステートメントのシンタックスを変更し、さらにクエリーを引き起こして障害を与えたからです。 攻撃者は、このようにして得た認識から、適切な注釈用文字を用いた攻撃文字列をアレンジします。</P><pre><SPAN>a' OR 1=1--</SPAN><SPAN> </SPAN></pre><P>さらに、攻撃者は、標的のデータベースが SQL であることを把握しているため、メタ テーブルおよび <I>xp_cmdshell</I> のような システムのストアド プロシージャを行う、より危険性の高いインジェクションが構築されやすくなり、また攻撃者にバッチ コマンドの可能性を知られてしまいます。</P><pre><SPAN>'; exec master..xp_cmdshell 'net user /add Attacker'—</SPAN><SPAN></SPAN></pre><pre><SPAN></SPAN></pre><pre><SPAN>'; update Accounts set balance = 1000000 when username = 'Attacker'—</SPAN><SPAN>&nbsp;</SPAN></pre><P>「ログインに失敗しました」などの一般的なエラー メッセージであれば、攻撃者を思いとどまらせることができるでしょう。 アプリケーションのエンド ユーザーから例外情報を保護しなければ、さらに乱用され、SQL インジェクションを含む<SPAN>&nbsp;</SPAN>で攻撃されるリスクが高まることになります。</P><H2><EM>ソース コードの公開</EM></H2><P>攻撃者は、例外情報漏えいを悪用して、アプリケーションのソース コードを盗もうと試みることがあります。 たとえば、図 2 に示されている ASP.NET 例外は、ソース コード ファイル名およびディレクトリを公開します。</P><P>&lt;&lt;図 2 をここに挿入する&gt;&gt;</P><P><B><SPAN>図 2 - ソース コード ファイルの名前を公開する ASP .NET エラー メッセージ</SPAN></B></P><P>&nbsp;攻撃者は、コマンド インジェクションといった別の攻撃を見つけ出せば、ファイルを入手できることを把握しています。</P><pre><SPAN>filename.txt'|type c:\inetpub\wwwroot\example\login.aspx.cs <SPAN></SPAN></SPAN></pre><P>これは、アプリケーションが、コマンド インジェクションの攻撃に対し脆弱であることを想定しています。 それにもかかわらず、アプリケーションが ASP.NET ページ login.aspx のソース ファイルの場所を公開しなかった場合、攻撃は実行可能とはなりません。</P><H2><EM>アプリケーションの内部構造を発見する</EM></H2><P>前回のシナリオで、攻撃者は、エラー メッセージの意味を解釈することでアプリケーションのしくみを見つけ出すことに重点を置いていました。 たとえば、アプリケーションは一部のファイル クエリーについては「ファイルが見つかりません」と応答しますが、その他については「アクセスが拒否されました」と応答します。 この情報に基づいて、攻撃者は、保護されているファイルが存在することを発見し、アプリケーションの動作を推測する手がかりにします。 </P><P>&nbsp;<B><SPAN>&nbsp;</SPAN></B></P><H1><SPAN>手順 2: 原因と対策を分析する</SPAN></H1><P>ASP.NET 例外情報漏えいのテストを行う次のステップでは、漏えいの原因およびその予防対策を確認します。 </P><H2><EM>アプリケーション レベルで例外を処理する</EM></H2><P>ASP.NET で例外情報の漏えいが起きた、最初の原因は例外処理の欠陥です。 たとえば、データベースが利用不可になった、またはテキストボックスのパラメータが誤ったシンタックスを保持していたとします。その場合、次のコードは、問題のスタック トレースを示す IIS で未処理の例外をトリガーします。</P><pre><SPAN>SqlConnection m_conn = new SqlConnection("Data Source=SQLServer1;Initial Catalog=example;Integrated Security=True");<BR>m_conn.Open();<BR>SqlCommand m_command = m_conn.CreateCommand();<BR>m_command.CommandText = "select * from Accounts where username = '" +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txbUserName.Text + "' and password = '" +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txbPassword.Text + "'";<BR>SqlDataReader m_reader = m_command.ExecuteReader();<BR>m_conn.Close(); </SPAN></pre><P><SPAN>try、catch、finally ブロックを使って構造化例外処理を追加し、一般的なエラー メッセージを印刷して例外情報の漏えいを防ぎます。</SPAN></P><pre><SPAN>try<BR>{<BR>	SqlConnection m_conn = new SqlConnection("Data Source=SQLServer1;Initial Catalog=example;Integrated Security=True");<BR>&nbsp;&nbsp; 	m_conn.Open();<BR>	&nbsp;&nbsp; SqlCommand m_command = m_conn.CreateCommand();<BR>	m_command.CommandText = "select * from Accounts where username = '" + txbUserName.Text + "' and password = '" + txbPassword.Text + "'";<BR>	SqlDataReader m_reader = m_command.ExecuteReader();<BR>&nbsp;&nbsp; 	m_conn.Close();<BR>}<BR>catch {<BR>	Response.Write("Application Error - Try again later");<BR>}<BR></SPAN></pre><P>上記に示した例は、try/catch ブロックがアプリケーションのクラッシュを阻止することを示す概念実証です。 しかし、一般的な try/catch ブロックは、例外処理に有効なプログラミングではありません。 </P><P>ASP.NET においてアプリケーション レベルで例外を処理するもう一つの方法は、プロジェクトにGlobal クラスを追加することです (Global.asax)。 Visual Studio においてこのアイテムを追加すると、<SPAN>Application_Error </SPAN> ルーティンが自動的に作成されます。 プロダクション サイトで、この機能は、例外情報を漏えいしない一般的なエラー メッセージで埋められる必要があります。</P><pre><SPAN><SPAN>void Application_Error(object sender, EventArgs e) <BR>{<BR>	// Code that runs when an unhandled error occurs<BR>&nbsp;&nbsp;&nbsp; 	Response.Write("Application Error");<BR>}</SPAN></SPAN>&nbsp;</pre><H2><EM>ページ レベルで例外を処理する</EM></H2><P>ASP.NET のデフォルトのコンフィグレーションでは、アプリケーションに障害が起きた場合、過度に例外情報を公開します。 これは、ASP.NET アプリケーション サイトの <I>web.config</I> ファイルがデフォルトで  <I>customErrors</I> タグを満たしていないために起こります (図 3 参照)。</P><P>&lt;&lt;図 &nbsp;3 をここに挿入する&gt;&gt;&nbsp;</P><P><B><SPAN>図 3 - ASP .NET web.config file&nbsp;&nbsp; の <I>customErrors</I> タグ</SPAN></B>&nbsp;</P><P>上図のコメントに示されるように、開発者はこの脆弱性から保護するように <I>customErrors</I> タグを設定する必要があります。 すべてのステータス コードに同じリダイレクトを使って最小限の情報を開示することができます。</P><pre><SPAN>&lt;customErrors mode="On" defaultRedirect="GenericErrorPage.htm"&gt;<BR>	&lt;error statusCode="403" redirect="GenericErrorPage.htm" /&gt;<BR>&nbsp;&nbsp; 	&lt;error statusCode="404" redirect="GenericErrorPage.htm" /&gt;<BR>&nbsp;&nbsp; 	&lt;error statusCode="500" redirect="GenericErrorPage.htm" /&gt;<BR>&lt;/customErrors&gt;<BR>&nbsp; </SPAN></pre><P>別の方法は、<I>customErrors</I> モードを <I>RemoteOnly</I> に設定する方法です。これにより、エンド ユーザーが一般的なエラーを受け取るのに対し、内部アプリケーション開発者は、詳細なエラー メッセージを受け取ります。 GenericErrorPage.htm は、一般的なエラー メッセージが記載された簡単な HTML ページになります。</P><pre><SPAN>&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;<BR>&lt;head&gt;<BR>&nbsp; &lt;title&gt;Application Error&lt;/title&gt;<BR>&lt;/head&gt;<BR>&lt;body&gt;<BR>&lt;h2&gt;Application Error&lt;/h2&gt;<BR>&lt;/body&gt;<BR>&lt;/html&gt;<BR>&nbsp;</SPAN><SPAN><BR>&nbsp;</pre></SPAN><H1><SPAN>手順 3: テストと調査を開始する</SPAN></H1><P>攻撃シナリオ、その原因、例外情報漏えいから保護する方法を理解できたら、異なるテスト ケースを送信し、この脆弱性を見つけて修正する必要があります。</P><H2><EM>悪意のある入力を送信する</EM></H2><P>情報漏えいバグをテストする最大の目的は、予期しない方法でアプリケーションを失敗させることです。 OWASP Fuzz Vectors [i]、エスケープ文字および特殊文字、および過度に長い文字列などの悪意のある攻撃文字列で構成される、予期せぬ入力を送信することから始めます。</P><P><B><I>データ型を変更する</I></B></P><P>型を正しく処理していないことが原因でアプリケーションの失敗が発生する場合もあります。 たとえば、アプリケーション ユーザーは次の URL の ID パラメータを使ってユーザーを特定し、ユーザー プロフィールを入手します。<B><SPAN></SPAN></B></P><pre><SPAN>http://www.example.com/getProfile.aspx?id=<STRONG>112</STRONG>&amp;username=testuser</SPAN></pre><P>文字列に対し ID タイプを変更することで無効なタイプの例外を生成することがあります。</P><pre><SPAN>http://www.example.com/getProfile.aspx?id=<SPAN><STRONG>abc</STRONG></SPAN>&amp;username=testuser</SPAN></pre><H2><EM>パラメーターを排除する</EM></H2><P>変更するデータ タイプの同じラインに従って、アプリケーションによって渡されるパラメータを削除して継続する必要があります。 このパラメータとは、POST ウェブ フォームの隠れたインプット タグから渡されたパラメータを含みます。 これは、それらを修正または削除するために、Burp Proxy または WebScarab などのプロキシの使用を必要とします。 </P><DIV><P>&lt;&lt;図 &nbsp;4 をここに挿入する&gt;&gt;&nbsp;</P></DIV><P><B><SPAN>図 4 - Burp Suite を使用して ASP .NET 要求の非表示の Web フォーム パラメーターを修正する</SPAN></B>&nbsp;</P><P>最後に、すべてのパラメータを削除していることを確認し、プリケーションで直接ページを呼び出します。 この作業もアプリケーションの障害を起こす可能性があります。</P><H2><EM>アプリケーションの応答の仕方を観察する</EM></H2><P>上記に示したテストケースを実行することは非常に重要です。与えられたインプットに対し、アプリケーションがどのように反応するかしっかりと注目します。 時としてアプリケーションは、明確な例外情報を示しませんが、代わりに、微妙に異なるエラーメッセージを提供します。 アプリケーションを攻撃するエラー メッセージの構想のしくみを推測するため、エラー メッセージ間での微妙な違いを見つけ出すことが必要です。</P><P><B><SPAN>&nbsp;</SPAN></B></P><H1><SPAN>手順 4: 追加テストを実行する</SPAN></H1><P>テスト ケースの第 1 段階が実行できたら、テスト ケースのデータを調整し、プロセスを自動化する必要があります。</P><H2><EM>異なるエンコーディングを使用する</EM></H2><P>ASP.NET のウェブ アプリケーションは、基礎となるプラットフォームに応じて異なるエンコーディング方法を選択することがあります。 たとえば、次の 2 つの URL は、実際同一のものです。<B><SPAN></SPAN></B></P><pre><SPAN>http://www.example.com/getProfile?id=a'+OR+1%3D1%23&amp;username=testuser</SPAN></pre><pre><SPAN>http://www.example.com/getProfile?id=a'%20OR%021=1#&amp;username=testuser</SPAN></pre><P>エスケープ文字や特殊文字は、異なる解釈が可能です。 アプリケーションの失敗する原因となる異なるエンコーディングを試すことが重要です。<B><SPAN></SPAN></B></P><H2><EM>テスト ケースを自動化する</EM></H2><P>最後に、手動による大量のテスト ケースの面倒なサブミットについて説明します。 テスト ケースのサブミットおよび検証処理を自動で行います OWASPのWebScarab [ii]といった悪意のある文字列を自動でテストすることでこの処理を手助けするツール (<I>fuzzers</I>) は、インターネット上にたくさんあります。 少なくとも 1 つのファジング ツールの使用方法を学習し、短時間でより多くのテストを実施します。</P><P><B><SPAN>&nbsp;</SPAN></B></P><H1><SPAN>結論</SPAN></H1><P>例外情報を漏えいするバグへの対応は、アプリケーション開発のセキュリティ テストフェーズ中に必要とされ、あらゆるセキュリティ意識チームの開発ポリシーとなるべきです。<SPAN>&nbsp; </SPAN>このガイドでは、脆弱性の影響について理解を深めるため、ASP.NET ウェブ アプリケーションにおける最も一般的な攻撃シナリオ、そして、バグの発生原因とその予防対策について説明しました。 テスト セクションでは、情報漏えいバグを適切に発見するために必要な複数のテスト方法を説明しました。 異なるインプット文字列を持つアプリケーションのテストにはよく気を付け、過度に情報を開示するエラー メッセージを見抜いてください。<B><SPAN></SPAN></B></P><DIV><BR><HR><DIV><P><SPAN>[i] <B>WebScarab による ファジング</B>(OWASP) </SPAN><A href="http://www.owasp.org/index.php/Fuzzing_with_WebScarab"><SPAN>http://www.owasp.org/index.php/Fuzzing_with_WebScarab</SPAN></A><BR></P></DIV></DIV><P><SPAN>[ii] <STRONG>OWASP テストガイド 付録 C: Fuzz Vectors&nbsp;</STRONG>(OWASP)&nbsp;</SPAN><SPAN><A href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors"><SPAN>http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</SPAN></A></SPAN><SPAN></SPAN></P>]]></Data>
  </Content>
</TeamMentor_Article>