<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-1633027854" Content_Hash="1400333414">
  <Metadata>
    <Id>0949b803-4421-4fd3-a291-38fd1a582fe2</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>認可の粒度を検討する</Title>
    <Category>認可</Category>
    <Phase>設計</Phase>
    <Technology>Web アプリケーション</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>適用対象</h1>
  <ul>
    <li>Web アプリケーション</li>
  </ul>
  <h1>行うべき事柄</h1>
  <p>サイト内の認証部分において使用する認可の粒度を考慮します。 アプリケーション レイヤーを超えてリソースにアクセスするために使用するアイデンティティを選択します。</p>
  <h1>理由</h1>
  <p>ユーザーごとの認可、監査、ユーザーごとのデータ取得を支援するために、多様なアプリケーション階層、多くのコンピュータ境界を越えて最初の呼び出し元のアイデンティティをフローすることが必要になります。 たとえば、バックエンドのリソースマネージャが呼び出し元ごとの認可を行う必要がある場合、呼び出し元のアイデンティティをリソースマネージャに渡さなければなりません。 リソースマネージャの認可要件およびシステムの監査要件に基づいて、アプリケーションを介してどちらのIDを提供する必要があるのかを特定します。&nbsp;</p>
  <h1>状況</h1>
  <p>ウェブ ベースのアプリケーションから、オプションでウェブサービス、企業サービス、.NETリモート処理コンポーネントからリソースにアクセスする。 </p>
  <h1>対策</h1>
  <p>粒度や拡張性の度合いがそれぞれ異なる3つの一般的な認可モデルがあります。</p>
  <p>粒度による方法では多くの場合、偽装に依存しています。 リソース アクセスは、呼び出し元のセキュリティ コンテキストを使用して行われます。 安全なリソース(通常、ファイルや表、または両方)上のWindows ACLが、リソースへのアクセスを呼び出し元が許可されるかどうかを決定します。 アプリケーションで主にユーザー固有のリソースへのアクセス権が提供される場合は、この方法が適しています。 これには付加的な利点があり、最初の呼び出し元のセキュリティ コンテキストがオペレーティング システム レベルで循環するので、アプリケーションの階層全体でオペレーティング システム レベルの監査を実行できます。 ただし、この方法では、データベース アクセスの効果的な接続プーリングができないため、アプリケーションの拡張性が不十分になる問題があります。 結果として、この方法は、規模が限定されるイントラネットベースのアプリケーションに最も多く見られます。 </p>
  <p>
    <b>
      <i>エンド ユーザー別認可レベルの粒度を示す偽装モデル</i>
    </b>
  </p>
  <p>粒度が最も小さいものの拡張性が最も高い方法では、アプリケーションのプロセス ID がリソース アクセスに使用されます。 この方法では、データベース接続プーリングがサポートされますが、これは、最初の呼び出し元の ID にかかわらず、データベース内のアプリケーションの ID に与えられるアクセス許可が共通であることを意味します。 主要な認可は、アプリケーション内で同じ特権を共有するユーザーをグループ化するロールを使用して、アプリケーションの論理中間層で実行されます。 クラスおよびメソッドへのアクセスは、呼び出し元のロール メンバーシップに基づいて制限されます。 ユーザーごとのデータの取得をサポートするためによく使用される方法は、データベース テーブルに ID 列を追加して、取得するデータをクエリ パラメーターを使用して制限することです。 たとえば、ストアド プロシージャ パラメーターを介してアプリケーション レベル (オペレーティング システム レベルではなく) で最初の呼び出し元の ID をデータベースに渡して、以下のようなクエリを作成できます。</p>
 <pre>SELECT field1, field2, field3 FROM Table1 WHERE {some search criteria} AND UserName = @originalCallerUserName</pre>
  <p>このモデルは、信頼されたサブシステム モデルと呼ばれますが、信頼されたサーバー モデルと呼ばれる場合もあります。 </p>
  <p>
    <b>
      <i>データベース接続プーリング対応の信頼済みサブシステム モデル</i>
    </b>
  </p>
  <p>3 番目の選択肢は、呼び出し元のロール メンバーシップに基づいて、限定された ID セットをリソース アクセスに使用することです。 これはまさに、前述の 2 つのモデルの混合です。 呼び出し元は、アプリケーションの論理中間層のロールにマップされ、クラスとメソッドへのアクセスはロール メンバーシップに基づいて制限されます。 ダウンストリーム リソース アクセスは、現在の呼び出し元のロール メンバーシップにより決定される限定された ID セットを使用して実行されます。 この方法の利点は、データベース内の独立したログインにアクセス許可を割り当てることができ、接続プーリングが接続の複数プールで依然として有効であるということです。 Windows 認証を使用してダウンストリーム リソース アクセスに異なるセキュリティ コンテキストを設定するために複数のスレッド アクセス トークンを作成することは、特権操作であるため、特権プロセス アカウントが必要になることが欠点です。 これは最小特権の原則に反します。 </p>
  <h1>その他のリソース</h1>
  <ul>
    <li>安全なASP.NETアプリケーション認証、認可、セキュア通信を確立する&nbsp;<a href="http://msdn2.microsoft.com/en-us/library/aa302383.aspx">http://msdn2.microsoft.com/en-us/library/aa302383.aspx</a><li>セキュアなウェブアプリケーションのための設計ガイドライン<a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a><li>セキュリティのためのアーキテクチャおよび設計レビュー<a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a><li>ASP.NETアプリケーションおよびウェブサービスをセキュアに保つ <a href="http://msdn2.microsoft.com/en-us/library/aa302435.aspx">http://msdn2.microsoft.com/en-us/library/aa302435.aspx</a></li></li></li></li>
  </ul>
  <hr />
  <p>出典: Microsoft patterns & practices guidance</p>]]></Data>
  </Content>
</TeamMentor_Article>