<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1225575102" Content_Hash="1292725468">
  <Metadata>
    <Id>5f03fd66-7ad6-49ce-8094-da0479b45200</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>データフロー解析を実行する</Title>
    <Category>セキュリティ工学</Category>
    <Phase>実装</Phase>
    <Technology> 任意</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>データフロー解析と呼ばれる手法を使用し、不適切な入力処理に関連するバグを明らかにします。&amp;nbsp;アプリケーションには様々なデータフローが存在する可能性があるため、優先順位を付けて作業に集中します。&amp;nbsp;このプロセスは次のように機能します。</p>
  <ol>
    <li>入力場所ごとに、入力ソースの信頼度を判別します。&amp;nbsp;疑わしい場合は、信頼しないでください。<li>考えられる出力までのデータの流れを追跡し、途中にデータ検証の形跡があればそれをメモします。<li>次の入力に移動して、続行します。</li></li></li>
  </ol>
  <h1>理由</h1>
  <p>データフロー解析を使用し、入力検証に関連する脆弱性を明らかにします。</p>
  <h1>状況</h1>
  <p>アプリケーション開発ライフ サイクルの開発段階でデータフロー解析を実行します。</p>
  <h1>対策</h1>
  <p>データフロー解析とは、入力ポイントから出力ポイントまでデータを追跡するために使用されるメカニズムです。&amp;nbsp;データフロー解析と呼ばれる手法を使用し、不適切な入力処理に関連するバグを明らかにします。&amp;nbsp;アプリケーションには様々なデータフローが存在する可能性があるため、優先順位を付けて作業に集中します。&amp;nbsp;このプロセスは次のように機能します。</p>
  <ol>
    <li>入力場所ごとに、入力ソースの信頼度を判別します。&amp;nbsp;疑わしい場合は、信頼しないでください。<li>考えられる出力までのデータの流れを追跡し、途中にデータ検証の形跡があればそれをメモします。<li>次の入力に移動して、続行します。</li></li></li>
  </ol>
  <p>作業が終了したときには、各入力データが通過するすべての関数と、最終地点である出力のリストが完成します。&amp;nbsp;入データが解析され、最終的にたどり着く出力場所が複数ある場合に注意を払うことを忘れないでください。&amp;nbsp;また、中間の出力場所にも注意します。&amp;nbsp;たとえば、入力はデータベースに保存された後で Web ページ コンテンツに配置されることもあります。<br />各入力ソースの信頼性の程度を判断することは困難です。&amp;nbsp;コンポーネント外からの入力はすべて信頼せず、すべてのデータを検証することが理想的です。&amp;nbsp;しかしパフォーマンスやメンテナンス上の理由から、これが現実的でない場合もあります。&amp;nbsp;一般的には、身近なコードは信頼性が高く、よく知らないコードは信頼性が低くなります。&amp;nbsp;信頼境界を判断する例を以下に示します。</p>
  <ul>
    <li>
      <strong>信頼度高</strong>
      <ul>
        <li>コンポーネント内でレビューしているコードからの入力<li>良く知られていて、厳密に名前が指定され、管理されたアセンブリまたはサイン付き/ハッシュ付のネイティブ ライブラリからの入力<li>コンポーネントによってのみ使用され、データのすべてが適切に検証されていることを証明できるデータベースからの入力<li>既知の良好なソース (IPSec または SSL) の署名付きのネットワーク データ</li></li></li></li>
      </ul>
      <li>
        <strong>信頼度中</strong>
        <ul>
          <li>厳密に名前が指定されていない、または署名付きではないが、サーバに対してローカルな、既知の良好なアセンブリまたはネイティブ ライブラリからの入力<li>信頼性のあるユーザーのみがアクセスできるパブリック インターフェイスからの入力<li>信頼性のあるユーザーのみがアクセスできる UI からの入力<li>信頼性のないユーザーがアクセスできないネットワーク データ (データセンター内部のセグメント化された LANなど)</li></li></li></li>
        </ul>
        <li>
          <strong>信頼度低</strong>
          <ul>
            <li>クライアント側にあり、厳密な名前が指定されておらず署名付きでもないアセンブリまたはネイティブ ライブラリからの入力<li>クライアント コードからの入力<li>ネットワークを介した入力<li>ファイルからの入力<li>任意のユーザーがアクセス可能なパブリック インターフェイスからの入力<li>任意のユーザーがアクセス可能な UI からの入力<li>他のコンポーネントやプロセスと共有されているデータベースからの入力</li></li></li></li></li></li></li>
          </ul>
        </li>
      </li>
    </li>
  </ul>
  <p>ソースまでのすべての過程を追跡し、最も弱い部分を基準に信頼性を判断してください。 追跡を行う際には注意深くコードを観察し、信頼性の低い入力に対しては厳密に入力検証を行い、信頼性が中程度の入力に対しては適度に実行されていることを確認します。&amp;nbsp;アプリケーションが信頼できないデータを受信するとすぐに呼び出される共通の検証ルーティンのセットを設定することが理想的です。&amp;nbsp;これにより、新しい情報が発見された際に更新できる中心的な障害点が確立されます。&amp;nbsp;ただし、データの信頼性を判断することに加えて、データがどのように使用されるかを認識してその検証方法を確認することが必要です。&amp;nbsp;ここでデータフロー解析が重要な意味を持ちます。&amp;nbsp;たとえば、信頼されていないデータの最終的な出力がデータベースである場合、SQL インジェクションの問題を確認する必要があります。&amp;nbsp;データが計算に使用される場合は、数値のオーバーフロー/アンダーフローを確認する必要があります。&amp;nbsp;データが Web ページに表示される場合、クロス サイト スクリプティングの問題を確認する必要があります。&amp;nbsp;検証ルーティンのレビュー中、検証は常にオプトアウトではなくオプトインでなければならないことに注意してください。 悪いものを正確に定義するよりも、良いものを定義するほうが簡単です。</p>
  <p>一般的な入力検証バグは次のとおりです。</p>
  <h2>数値のアンダーフローおよびオーバーフロー</h2>
  <p>この問題は、計算のデータ値がデータ型の許容する範囲を上回るか下回る場合に発生します。&amp;nbsp;この場合、値はラップアラウンドされ、一般的に期待値を大幅に上回るか下回ります。&amp;nbsp;たとえば、符号なし整数に -1 を割り当てると、実際の値は 40 億を超えます。&amp;nbsp;VB では、オーバーフロー/アンダーフローが発生するとすぐに例外がスローされますが、C# はスローされません。&amp;nbsp;コード全体でデータを追跡する際、計算に使用されるデータをユーザーが入力する場所で、アンダーフロー/オーバーフロー条件が発生しないことを確認します。</p>
  <p>例: </p>
 <pre>int&amp;#91;&amp;#93;filter(uint len, int&amp;#91;&amp;#93;numbers)<br />&amp;#123;<br />  uint newLen =&amp;nbsp; len &amp;#42; 3/4;<br />  int&amp;#91;&amp;#93;buf = new int&amp;#91;newLen&amp;#93;;<br />  int j = 0;<br />  for(int i = 0; i &lt; len; i&amp;#43;&amp;#43;)<br />  &amp;#123;<br />&amp;nbsp;&amp;nbsp;if (i &amp;#37; 4 &amp;#33;= 0)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;buf&amp;#91;j&amp;#43;&amp;#43;&amp;#93;= numbers&amp;#91;i&amp;#93;;<br />  &amp;#125;<br />&amp;nbsp;return buf;<br />&amp;#125;</pre>
  <p>問題は len の値を計算する際に、コードがまず len &amp;#42; 3 を計算し、その後 4 で割っていることです。&amp;nbsp;len が十分に大きい場合 (14 億)、len &amp;#42; 3 はオーバーフローし、newLen に小さすぎる値が割り当てられます。&amp;nbsp;このコードの結果、未処理の IndexOutOfRange 例外となります。</p>
  <h2>SQL インジェクション</h2>
  <p>SQL インジェクション攻撃は、信頼されない入力が SQL クエリーの論理を予期しない方法で変更できる場合に発生します。&amp;nbsp;コード全体で追跡を行う際、SQL クエリーで使用されるすべての入力が検証されていることを確認するか、SQL クエリーがパラメータ化されていることを確認します。</p>
  <p>例: </p>
  <p>コード内の SQL クエリーは次のようになります。</p>
 <pre>query = &amp;#8220;SELECT &amp;#42; FROM USERS WHERE USER_ID = &amp;#8216;&amp;#8221; &amp;#43; userIdFromWebPage &amp;#43; &amp;#8220;&amp;#8217;&amp;#8221;;</pre>
  <p>userIdFromWebPage は、未検証の信頼されていないデータを含む変数です。&amp;nbsp;たとえば、&amp;#8220;&amp;#8217; or 1=1 -&amp;#8220;、&amp;#8220;&amp;#8217; ;DROP TABLE users -&amp;#8220;、または &amp;#8220;&amp;#8217; ;exec xp_cmdshell(&amp;#8216;format c:&amp;#8217;) -&amp;#8220; を含む場合を想定してください。&amp;nbsp; 最終的なクエリーは次のようになります。</p>
 <pre>&amp;nbsp;&amp;#8220;select &amp;#42; FROM USERS WHERE USER_ID = &amp;#8216;&amp;#8217; ;exec xp_cmdshell(&amp;#8216;format c:&amp;#8217;) -&amp;#8221;</pre>
  <p>これにより、データベース サーバの c:\ ドライブがフォーマットされます。 </p>
  <p>コードは次のように作成してください。</p>
 <pre>SqlCommand queryCMD = new SqlCommand("GetUser", sqlConn);<br />queryCMD.CommandType = CommandType.StoredProcedure;<br />SqlParameter myParm = queryCMD.Parameters.Add("&amp;#64;UserID", SqlDbType.Int, 4);<br />myParm.Value = userIdFromWebPage;<br />SqlDataReader myReader = queryCMD.ExecuteReader();</pre>
  <h2>クロスサイト スクリプティング</h2>
  <p>クロスサイト スクリプティングは、攻撃者がアプリケーションに入力したスクリプト コードが、エコー バックされてアプリケーションのセキュリティ コンテキストで実行される場合に発生します。&amp;nbsp;これにより、攻撃者はフォームデータや Cookie を含むユーザー情報を盗用できます。&amp;nbsp;この脆弱性は、Web アプリケーションが Web コンテンツに、フィルタリングされていないユーザー入力を エコーバックする場合には必ず生じる可能性があります。</p>
  <p>コード全体の追跡を行う際に、信頼されていないデータが最終的に Web  ページ コンテンツとして出力される場合は、データに HTML タグが含まれていないことを確認します。&amp;nbsp;データが、信頼されていない入力から経由地を通ってウェブ ページ出力に移動する可能性があることに注意してください。たとえば、データベースに保存され、その後クエリーによってデータベースから取り出されたデータがウェブ ページに表示されることもあります。&amp;nbsp;このバグを防止するには、ユーザー入力が Web コンテンツにエコー バックされる前に HTMLEncode または URLEncode を使用します。</p>
  <p>例: </p>
  <p>この例では、ウェブ アプリケーションは <a href="http://www.contoso.msft">http://www.contoso.msft</a> でホストされます。&amp;nbsp; ASP スクリプトは、&amp;#8220;Welcome &lt;UserName&gt; &amp;#8221;と出力することを目的としています。 UserName の値はフィルタリングもエンコードもされないため、これはクロスサイト スクリプティングの脆弱性を生じます。 攻撃は次のように進行します。</p>
  <p>1.) 攻撃者が、疑いを抱いていないユーザーに悪意のある HTML フォームを含む電子メールを送信します。</p>
  <p>2.) ユーザーが電子メール内のリンクをクリックすると、Contoso ページに post 要求が送信されます。 要求には、username フィールドの値のための JavaScript が含まれます。</p>
  <p>3.) Contoso サイトが &amp;#8220;username&amp;#8221; の値 (実際には 攻撃者が生成した JavaScript) をユーザーのブラウザーに送信し、ブラウザーは、スクリプトのソースを Contoso サイトであるとみなして実行します。 この場合、スクリプトはページに関連するすべての Cookie データを攻撃者のマシンに送信します。</p>
  <h2>正規化</h2>
  <p>正規化エラーは、リソースを表す方法が複数存在し、異なる表現によって様々なセキュリティ論理が実行される場合に発生します。&amp;nbsp;この問題が発生する可能性のあるリソースのタイプは複数あります。</p>
  <ul>
    <li>
      <strong>ファイル リソース</strong>
      <ul>
        <li>部分パスを使用すると、予測していないファイルが読み込まれる場合があります。<li>PATH 環境変数を使用すると、アプリケーションで使用しているパスが攻撃者に制御される場合があります。</li></li>
      </ul>
      <li>
        <strong>URL</strong>
        <ul>
          <li>ドットなし IP などの IP アドレスの別の表現を使用すると、予測していない URL が読み込まれる可能性があります。<li>&amp;#37;20 (スペース) などのエンコードされた文字を使用すると、予測していない URL が読み込まれる可能性があります。</li></li>
        </ul>
      </li>
    </li>
  </ul>
  <p>このバグにより、攻撃者は他の手段ではアクセスできないリソースにアクセスできるようになります。&amp;nbsp;コード全体の追跡を行う際に、ユーザー入力に基づいてリソースがアクセスされる部分を詳細に確認します。&amp;nbsp;Path.GetFullPath を使用する前にファイル名が正規化されていることを確認します。&amp;nbsp;Uri.AbsoluteUri を使用する前に URL が正規化されていることを確認します。&amp;nbsp;保護の余分なレイヤーのために、 CAS を使用します。 不要なアクセス許可を拒否すると同時に、ランタイムに必要なものを指示します。</p>
  <p>例: </p>
 <pre>&amp;#91;assembly:FileIOPermission( SecurityAction.RequestMinimum, Read = "c:\\temp" )&amp;#93;<br />&amp;#91;assembly:FileDialogPermission( SecurityAction.RequestOptional )&amp;#93;<br />&amp;#91;assembly:FileIOPermission( SecurityAction.Deny, Write = "c:\\windows" )&amp;#93;</pre>
  <h2>ネイティブ コードの問題</h2>
  <p>レビューしているコードがネイティブ コードを呼び出す場合、セキュリティを保証するために追加チェックが必要になります。&amp;nbsp;データの正当性とメモリの健全性についての マネージ コードでの仮定は、ネイティブ コードを実行する場合には、成立しない場合があります。&amp;nbsp;マネージ コードでは起こりえないまたは異常な次のバグが、ネイティブ コードでは高い確率で発生します。</p>
  <h2>バッファ オーバーフロー</h2>
  <p>バッファ オーバーランは、任意のコードの実行を導く可能性のある典型的な脆弱性です。&amp;nbsp;この脆弱性のエクスプロイトが成功するかどうかは、システム アーキテクチャーの低レベルの詳細に左右され、本ガイドの対象範囲外です。しかし、問題の重要性と発生頻度を考慮すると、これらの脆弱性が生じた場合にはそれを認識することが重要になります。</p>
  <p>マネージ コードでは、共通言語ランタイムが下層マシンのアーキテクチャーを抽象化するため、バッファ オーバーフローはほとんど発生しません。&amp;nbsp;しかし、安全でないとマークされたコードがメモリに直接アクセスすることが可能なため、バッファ オーバーフローを含む場合があります。&amp;nbsp;さらに多くのアプリケーションでマネージ コードとアンマネージ コードが混在しているため、アンマネージ コードを詳細に確認する必要があります。 </p>
  <p>コード全体の追跡を行う際は、安全でないコードが次のルールに従っているかどうかを確認します。</p>
  <ul>
    <li>可変長データをバッファにコピーするすべての関数が、最大長のパラメータを適切に使用していることを確認します。<li>データの切り詰めについて他のレイヤーや階層を信頼しないでください。<li>問題が発生する場合は、バッファを拡張するのではなく、必ずデータを切り詰めることを選択してください。&amp;nbsp;バッファを拡張すると、問題を下流に移すだけになる場合があります。<li>すべてのアンマネージ コードが /GS オプションでコンパイルされていることを確認します。</li></li></li></li>
  </ul>
  <p>例: </p>
 <pre>public void ProcessInput<br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;char&amp;#91;&amp;#93;data = new char&amp;#91;255&amp;#93;;&amp;nbsp; <br />&amp;nbsp;&amp;nbsp;GetData(data);<br />&amp;#125;<br /><br /><br />public unsafe void GetData(char&amp;#91;&amp;#93;buffer)<br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;int ch = 0;<br />&amp;nbsp;&amp;nbsp;fixed (char&amp;#42; pBuf = buffer)&amp;#123;<br />&amp;nbsp;do<br />&amp;nbsp;&amp;#123;<br />&amp;nbsp;&amp;nbsp;ch = System.Console.Read();<br />&amp;nbsp;&amp;nbsp;&amp;#42;(pBuf&amp;#43;&amp;#43;) = (char)ch;<br />&amp;nbsp;&amp;#125;while(ch &amp;#33;= '\n');<br />&amp;nbsp;&amp;nbsp;&amp;#125;<br />&amp;#125;</pre>
  <p>1 行が 255 文字を超えると、オーバーフローが必ず発生します。&amp;nbsp;このコードには 2 つ問題があります。</p>
  <ol>
    <li>ProcessInput 関数は 255 文字分のスペースしか割り当てません。<li>GetData 関数は入力時に配列のサイズをチェックしません。</li></li>
  </ol>
  <h2>書式文字列</h2>
  <p>書式文字列のバグは、変数や &amp;#37;n 書式指令を処理する printf 系関数から生じます。&amp;nbsp;printf 系関数は、書式文字列に &amp;#8220;&amp;#37;&amp;#8221; があるたびにスタックをポップします。&amp;nbsp;十分な数の &amp;#37;&amp;#8217;  を使用すると、スタックをトラバースしてスタック内の任意の場所やさらに上の場所に到達する可能性があります。&amp;nbsp;また、&amp;#37;n を使用すると、スタック内のあらゆる場所に任意のデータを書き込めるようになります。&amp;nbsp;コード全体の追跡を行う際は、書式文字列にユーザー入力が決して含まれていないことを確認します。&amp;nbsp;アンマネージ コードでのみ発生する問題であるため、信頼されていない入力がネイティブ ライブラリへの呼び出しで使用される場合以外は考慮する必要はありません。</p>
  <p>例: </p>
 <pre>void main (int argc, char &amp;#42;&amp;#42;argv)<br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;#42; Whatever the user said, spit back&amp;#33; &amp;#42;/<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;printf (argv&amp;#91;1&amp;#93;);<br />&amp;#125;</pre>
  <p>この例では、信頼されていない入力がコマンド ライン パラメータの形で printf ステートメントに直接渡されています。&amp;nbsp;これにより、攻撃者は書式文字列の  命令を文字列に含め、スタック上の任意のメモリを返したり変更したりするようにアプリケーションに強制できるようになります。</p>
  <h1>関連する項目</h1>
  <ul>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>