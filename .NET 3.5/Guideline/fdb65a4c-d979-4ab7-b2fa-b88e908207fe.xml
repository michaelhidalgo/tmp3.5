<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1398681752" Content_Hash="-1737058181">
  <Metadata>
    <Id>fdb65a4c-d979-4ab7-b2fa-b88e908207fe</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>必要な場合を除き、偽装を使用しない</Title>
    <Category>なりすましと委任</Category>
    <Phase>設計</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>必要な場合を除き偽装の使用は回避し、必要な場合でも可能な限りその使用を制限します。</p>
  <h1>理由</h1>
  <p>プログラム型の偽装が適切に行われていないと、セキュリティの脆弱性を招くおそれがあります。 特にマルチスレッド アプリケーションにおいて、正しく偽装を行うのは困難です。 可能な場合には、リソースへのアクセスに、カスタム ドメイン プロセス ID などの代替アプローチを使用します。 プログラム型の偽装は、以下の理由により、可能な限り避ける必要があります。</p>
  <ul>
    <li>スレッド偽装トークンがスレッドにわたって伝播されていない、スレッド スイッチが原因でエラーが発生しやすい。 <li>一部のプログラム上の手法では、避けた方が望ましい Credential 情報を保存することが要求されます。 <li>一部のプログラム手法でプロセス アカウントに追加の特権の付与が必要になるが、これは避けるべきである。 例えば、Windows Server 2000 で <strong>LogonUser</strong> を呼び出す場合、またはWindows Server 2003 で偽装レベル トークンを取得するためにユーザー プリンシパル名からトークンを生成する新しい <strong>WindowsIdentity</strong> コンストラクタを使用する場合、プロセス アカウントに “オペレーティング システムの一部として機能” を付与する必要があります。 <li>偽装中に例外が発生すると、コール スタック内の上位にある悪意のあるコードが、偽装された ID を使用して実行される可能性がある。 これは、特に高度な特権を持つアカウントを偽装している場合に、セキュリティ上の問題を招くことがあります。 詳細については、「<a href="/article/5b6c71b0-cb89-4435-b30e-2fd76347078e">偽装中に例外を伝播しない</a>」を参照してください。</li></li></li></li>
  </ul>
  <h1>状況</h1>
  <p>常に、可能な限り、アプリケーションの偽装の使用を制限します。 アプリケーションに偽装が必要な場合には、<a href="/article/97dfd32f-deb6-4016-b3ff-24147a959521">LogonUser API は使用しない</a>ガイドラインを読んで、ユーザーを偽装する適切な方法を決定します。</p>
  <h1>対策</h1>
  <p>既定では、ASP.NET は以下の構成で実行します:</p>
  <ul>
    <li>IIS 5：アプリケーションは、デフォルトで最小限の特権付き ASPNET アカウントを使用して実行されます。 <li>IIS 6 以降：アプリケーションは、最小限の特権付き Network Service アカウントを使用したアプリケーション プール内で実行されます。 カスタム サービス アカウントを使用して ASP.NET Web アプリケーションを実行する必要がある場合は、最小限の特権付きアカウントを作成してください。 カスタム サービス アカウントを作成して、お使いのアプリケーションを同一サーバ上にある別のアプリケーションから分離したり、各アプリケーションの監査を別々に行ったりできるようにする必要があるかもしれません。</li></li>
  </ul>
  <p>偽装は潜在的に高い危険性があります。 安全に使用できる場合もありますが、絶対に必要ではない限り、偽装を回避することをお勧めします。 </p>
  <p>ユーザーのセキュリティ コンテキスト全体ではなく、そのユーザーのID だけをダウンストリームにセキュアに渡す必要がある場合は、偽装を使用しないでください。 たとえば、データベースのバックエンドがそのデータベースに接続しているユーザーの ID を知る必要がある場合、ウェブ フロント エンドが信頼済みサブシステムとしての役割を果たし、そのユーザーをデータベースに対して偽装することなく、セキュアな接続を通じてユーザー ID をデータベースに渡すことで、ユーザーの認証および認可をすることができます。 これらの場合に偽装を使用しないことがより安全であるだけではなく、より迅速でもあります&amp;#8212;この状況でユーザーを偽装することは、接続プールの使用を防ぎ、それによってオーバーヘッドがたくさん増えます。</p>
  <p>できる限り、リソースにアクセスするために 1 人のユーザーを偽装することは回避してください。 より適切な解決策としては、アプリケーションの通常のプロセス ID アクセスが許可されるように ACL を必要に応じて変更するか、または中間ポイントでアクセス制御の処理を行う信頼済みサブシステム ソリューションを使用します。 ACL と信頼済みサブシステムの両方で注意を払う必要がありますが、偽装される ID で実行できることをすべてプロセスに許可するのでなく、呼び出しプロセスに対して必要な、単一の特定の機能だけを提供するという利点があります。 </p>
  <p>アプリケーションの機能において偽装が必要となる可能性がある最も一般的な状況は:</p>
  <ul>
    <li>
      <strong>最初の呼び出し元を偽装する。</strong> アプリケーションのドメイン ユーザー アカウントに対して設定された ACL により保護された、Windows リソースにアクセスしたい場合。 この方法は、アプリケーションがファイアウォールの後ろに格納されていて、組織のドメイン コントローラーが制限される場合にも有効です。 <li><strong>最初の呼び出し元をプログラム的に偽装する。 </strong>ほとんどのリソースには、アプリケーションのプロセス ID を用いてアクセスするが、特定のメソッドが最初の呼び出し元の ID を用いる必要がある場合。 <li><strong>特定の Windows ID を偽装する。</strong> 特定の ID または複数の Windows ID を使用してあるリソースへアクセスする必要がある場合。</li></li></li>
  </ul>
  <p>これらはすべて偽装の妥当な使用ですが、偽装を使用しない限り実行できないアクションであることを確認するよう、実装する前に注意する必要があります。</p>
  <h1>問題の例</h1>
  <p>MyApp は、MyCorp の人事アプリケーションです。 データベース内のユーザー データにセキュリティを提供するために、アプリケーションはデータベースと通信する際に、ローカルでセキュリティ ポリシーを適用する代わりに接続ユーザーを偽装します。 これにより、攻撃はアプリケーション アカウントとしてだけでなく、ドメイン内の実際のユーザーとしてアクションを取ることができるようになります。 ハードニングされていないSQL Server への SQL インジェクションの場合に、これは重要な可能性があります。</p>
 <pre>WindowsIdentity winIdentity = new WindowsIdentity(username &amp;#43; "&amp;#64;NTDOMAIN");WindowsImpersonationContext ctx = winIdentity.Impersonate(); // Access the database</pre>
  <h1>ソリューションの例</h1>
  <p>MyApp は、MyCorp の人事アプリケーションです。 データベース内のユーザー データにセキュリティを提供するために、アプリケーションはアプリケーション レイヤーに目的とする一連のビジネス ルールを慎重に強制し、データベースに接続するために単一の低い特権のアカウントを使用します。 アカウントは完全なドメイン ユーザーではなく、事前に指定した一連のストアド プロシージャを実行すること以外のデータベース内の特権はありません。 SQL インジェクションまたはコード インジェクションによる危害を受けても、システムは昇格された特権では実行されません。</p>
  <h1>関連する項目</h1>
  <ul>
    <li>
      <a href="/article/56a1ea9e-8981-4315-a048-127a2bea2285">ガイドライン: 特権アカウントの使用を監視すること</a>
      <li>
        <a href="/article/fab1733c-61d7-46a8-88c6-2617a643c0d9">ガイドライン: データベース アクセスには最小限の特権アカウントを使用する</a>
        <li>
          <a href="/article/3d7727d0-18ca-47c3-90f6-5c6c715c4f35">チェックリスト項目: 必要な場合を除き、偽装は使用しない </a>
        </li>
      </li>
    </li>
  </ul>
  <hr />
  <p>出典: Microsoft Patterns &amp; Practices ガイダンス</p>]]></Data>
  </Content>
</TeamMentor_Article>