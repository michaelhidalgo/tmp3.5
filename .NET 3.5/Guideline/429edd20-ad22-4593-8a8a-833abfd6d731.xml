<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="739841830" Content_Hash="-559573699">
  <Metadata>
    <Id>429edd20-ad22-4593-8a8a-833abfd6d731</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>ペネトレーション テストを実行する</Title>
    <Category>セキュリティ工学</Category>
    <Phase>テスト</Phase>
    <Technology> 任意</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>アプリケーションに脆弱性がないかテストします。 ペネトレーション テストを実行する方法には様々なものがあり、多くの場合、実際の手順はシステムまたはテストするアプリケーションの仕様によって異なります。 1 つのオプションとして、情報セキュリティのコンサルタント会社と契約して、ペネトレーション テストを実施する方法があります。 ペネトレーション テストの実施方法の 1 つとして、アプリケーション環境で自動化ツールにより一般的な脆弱性を調べて見つけやすい問題を発見し、次に手動により最も危険で一般的な種類の脆弱性と攻撃ベクトルを確認する方法論があります。</p>
  <h1>理由</h1>
  <p>ペネトレーション テストは、いち早く脆弱性を発見するのに役に立ちます。</p>
  <h1>状況</h1>
  <p>アプリケーション開発ライフ サイクルのテスト段階で、ペネトレーション テストを実行します。</p>
  <h1>対策</h1>
  <p>アプリケーションの ペネトレーション テストの準備が整ったら、必ず脅威モデルを使用してテスト計画を改善します。 脅威モデルの目的の 1 つは、アプリケーションのリスクを列挙して分類することであり、ペネトレーション テストの適切な起点となります。 脅威モデルを使用すると、攻撃ベクトルや攻撃が成功する条件を確定できます。 これらの進路および攻撃条件をテストすることで、アプリケーションのかなりの範囲をテストできます。</p>
  <p>セキュリティ テストは機能テストと異なることに注意してください。 機能テストはアプリケーションが行うべき動作に注目しますが、セキュリティ テストはアプリケーションが行うべきでない動作に注目します。 セキュリティの脆弱性はあいまいな場合があるため、ファイルシステムへの予期せぬ変更や、予期せぬネットワーク トラフィックなど、成功する攻撃のすべての兆候を検討します。</p>
  <p>環境の相互作用により、様々な欠陥が生じます。 リソースが利用できない、データがディスクにページアウトされるなど、プラットフォームの様々な局面で何が起こるかを検討します。多くの欠陥は、アプリケーションの環境を分析して初めて見つけることができます。 ネットワークのスニッフィングで機密情報を発見できるか、または機密情報を含む一時ファイルが見つかるかどうかを確認します。 簡単な目標については自動ツールを使用します。 見つけにくいバグについては、効果が証明されている手動テスト 手法を使用します。</p>
  <p>ペネトレーション テストを実施する場合は、一般的な攻撃や脆弱性を念頭に置いておくと非常に便利です。 このスライドは脆弱性の発見に適した様々な手法を示します。 このトピックの詳細については、Security Innovation のeラーニング コース How to Break Software Security(ソフトウェア セキュリティを破る方法）で扱っています。 以下は一般的な攻撃と脆弱性の例です。</p>
  <ul>
    <li>
      <strong>依存性への攻撃</strong>
      <ul>
        <li>ライブラリへのアクセスをブロック<li>レジストリ値を操作<li>破損したファイル (書き込み禁止、アクセス不可、データ エラーなど）やファイル名の使用をアプリケーションに強制<li>アプリケーションが書き込み、読み取り、作成、実行を行うファイルを置き換え<li>メモリー/ディスク スペース/ネットワークの可用性がストレスを受けた状態で動作することをアプリケーションに強制<li>ユーザー インターフェイスへの攻撃<li>入力バッファのオーバーフロー<li>すべてのコマンドライン スイッチおよび入力オプションを検査<li>エスケープ文字、文字セット、コマンドを調査</li></li></li></li></li></li></li></li></li>
      </ul>
      <li>
        <strong>設計への攻撃</strong>
        <ul>
          <li>一般的なデフォルト設定やアカウント名とパスワードの試行<li>保護されていないテスト API の暴露<li>すべてのポートへの接続<li>データ ソースの偽装<li>ループ条件のエクスプロイト<li>同じタスクを実行する代替ルートの使用<li>値をリセットすることをシステムに強制</li></li></li></li></li></li></li>
        </ul>
        <li>
          <strong>実装への攻撃</strong>
          <ul>
            <li>確認と使用の時間差<li>高度に保護されたファイルと同じ名前でファイルを作成<li>すべてのエラー メッセージを強制<li>一時ファイルを探し、機密情報を含む内容を画面表示する</li></li></li></li>
          </ul>
        </li>
      </li>
    </li>
  </ul>
  <h1>関連する項目</h1>
  <ul>
  </ul>
  <p>&amp;nbsp;</p>
  <h1>&amp;nbsp;</h1>]]></Data>
  </Content>
</TeamMentor_Article>