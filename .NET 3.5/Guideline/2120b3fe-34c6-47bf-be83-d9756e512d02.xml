<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1715125178" Content_Hash="-121247876">
  <Metadata>
    <Id>2120b3fe-34c6-47bf-be83-d9756e512d02</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>パスワードをメモリに残したままにしない</Title>
    <Category>認証</Category>
    <Phase>実装</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>パスワードは使用後にメモリから消去します。</p>
  <h1>理由</h1>
  <p>パスワードは、信頼関係の確立に使用される機微データです。 使用後にメモリに残っていると、攻撃者に悪用されてしまう可能性があります。</p>
  <h1>状況</h1>
  <p>アプリケーションがパスワードを扱う場合。</p>
  <h1>対策</h1>
  <p>パスワードが格納されていたメモリを上書きすると、パスワードを消去できます。 割り当て解除されたメモリがコレクションまたは再利用される時期について.NETガーベジ コレクタは何の保証もしないので、メモリの割り当て解除だけでは不十分です。 パスワードを新しいバッファに割り当てたりパラメーターに渡したりすると、常にそのパスワードはコピーされ、メモリ内の新しい場所に格納されます。 メモリを消去する場合は、すべてのインスタンスを消去するようにしてください。</p>
  <p>パスワードを扱う場合は以下の考慮事項に注意してください。</p>
  <ol>
    <li>
      <p>
        <strong>パスワードのすべての使用方法を確認します。 </strong>パスワードを扱うすべてのコード セグメント (関数とデータ メンバーの両方) を特定します。 対象となる関数とデータ構造は、アプリケーション全体に分散している場合があります。 アプリケーションを簡単に管理できない場合、パスワードを扱うすべてのコードを 1 箇所に集めるようにします。 </p>
      <li>
        <p>
          <strong>パスワードを可変オブジェクトに格納します。</strong> 可変オブジェクトでは、格納しているデータを上書きできます。 .NETではオブジェクトはガーベジ コレクタを通じて割り当て解除する必要があるので、このことは特に有用です。 従って、いつパスワード インスタンスが現在のプロセススペースから解放されるかは確実ではありません。 ミュータブルなオブジェクトの例としては、文字配列  (すなわち、char&amp;#91;&amp;#93;) があります。しかし、.NET 文字列はミュータブルなオブジェクトではありません。このため、割り当てを行うと現在のメモリ空間は変更できなくなります。そのため、いったん割り当てられたメモリ空間を変更することはできません。 パスワードを配列に保存する際は、.NET が Byte、Char、および Int32 などの初期のタイプに提供するラッパー構造の配列ではなく、byte、char、および int などの初期のデータ タイプの配列を使用していることを確認してください。 .NET文字列の使用を強制される場合(例えば、.NET文字列が取る関数を呼び出す時など)は、使用直前に文字列を構築するようにし、迅速なガーベジコレクションを促進するため終了次第新しい値を割り当ててください。 これは次善策であり、セキュリティ問題につながる可能性がありますが、.NET APIが変更可能なオブジェクトまたはSecureStringsの独占使用を許可するまでは、これは避けられないかもしれません。 </p>
        <li>
          <p>
            <strong>すべてのパスワード インスタンスを消去します。</strong> パスワードが格納されているすべてのメモリ ロケーションが、使用後に消去または上書きされるようにします。 パスワード インスタンスのポインターが失われると、その特定のメモリが消去されず、パスワードが漏えいしてしまう可能性があります。</p>
        </li>
      </li>
    </li>
  </ol>
  <h1>問題の例</h1>
  <p>以下のコードでは、パスワードを使用しています。 文字列へのポインターが取り外されガーベジコレクションが呼ばれますが、.NETはデータが消去されることを保証しません。</p>
 <pre>string pass = GetPassword();...pass = null;GC.Collect();</pre>
  <h1>ソリューションの例</h1>
  <p>以下のコードでは、パスワードを使用しています。 パスワードの使用後、メモリが明示的に消去されています。 文字列は不変オブジェクトであるため、このコードでは文字配列を使用してパスワードを格納しています。 これで、データを使用後に上書きできるようになります。 </p>
 <pre>char&amp;#91;&amp;#93;pass = GetPassword();<br />...<br />ClearPassword(pass);<br />pass = null;<br />...<br />void ClearPassword(char&amp;#91;&amp;#93;pass)<br />&amp;#123;       <br />&amp;#9;for(int i=0; i&lt;pass.Length; i&amp;#43;&amp;#43;)       <br />&amp;#9;&amp;#123;             <br />&amp;#9;&amp;#9;pass&amp;#91;i&amp;#93; = ' ';      <br />&amp;#9;&amp;#125;<br />&amp;#125;</pre>
  <h1>その他のリソース</h1>
  <ul>
    <li>.NET のガーベジ コレクタの詳細については、MSDN の「<a href="http://msdn2.microsoft.com/en-us/library/system.gc(vs.80).aspx">GC クラス</a>に関する文書」を参照してください。 <li>.NET のデータ型の詳細については、「<a href="http://msdn.microsoft.com/en-us/magazine/cc301569.aspx">.NET 型の基本</a>」を参照してください。</li></li>
  </ul>
  <h1>関連する項目</h1>
  <ul>
    <li>
      <a href="/article/bb200ff1-9bfb-4d7a-a048-575051c8c798">チェックリスト項目：パスワードがメモリ内に残されていない</a>
    </li>
  </ul>
  <hr />
  <p>出典: Microsoft Patterns &amp; Practices ガイダンス </p>]]></Data>
  </Content>
</TeamMentor_Article>