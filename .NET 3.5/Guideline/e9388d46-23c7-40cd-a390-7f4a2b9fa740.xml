<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-1247693165" Content_Hash="-795672754">
  <Metadata>
    <Id>e9388d46-23c7-40cd-a390-7f4a2b9fa740</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>すべての入力は悪意があると仮定する</Title>
    <Category>入力とデータの検証</Category>
    <Phase>設計</Phase>
    <Technology>Web アプリケーション</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>適用対象</h1>
  <ul>
    <li>Web アプリケーション</li>
  </ul>
  <h1>行うべき事柄</h1>
  <p>アプリケーションでは、入力すべてが悪意のあるものであると仮定して適宜対応しなければなりません。&nbsp; 入力は、検証された後で直ちに拒否またはサニタイズされ、使用中には十分に検疫され、出力で適切にエンコーディングされる必要があります。</p>
  <h1>理由</h1>
  <p>悪意のある入力は、Web アプリケーションにおける脆弱性の最大の単一原因であり、最も一般的な意味では、ほぼすべての問題の根本的原因です。&nbsp; 安全性を確保する唯一の方法は、多層防御と [既定で拒否する] ポリシーです。これは、基本的にすべての入力を、証明されるまでは悪意のある入力であると仮定することから始めます。 たとえば、文字列を返す外部 Web サービスを呼び出す場合、悪意のあるコマンドがないことがわかっていますか。 また、複数のアプリケーションが1つの共有データベースに書き込む場合、どうして安全だと分かるでしょうか。</p>
  <h1>状況</h1>
  <p>各アプリケーションでは、入力すべてが悪意のあるものであると仮定する必要があります。</p>
  <h1>対策</h1>
  <p>入力検証を正しく行うためには注意が必要で、 Web アプリケーションにとってこれがセキュリティ上の最大の問題であるのには理由があります。&nbsp; ただし、体系的なアプローチを使用すれば、この問題の解決はそれほど困難ではありません。&nbsp; 以下の手順を実行します。</p>
  <h2>1. すべての入力を判定する</h2>
  <p>最初の手順は、ユーザーによる制御が可能なアプリケーションのすべての内容を判定することです。&nbsp; ここでは、いくつかの驚くべきことがあります。通常の HTTP サーバー環境における多くの変数は、実際にはユーザーの要求から取得されるため、すべてがどこから取り出されるのかを具体的に把握するようにしてください。&nbsp; 簡潔なコメントをコードに残すことにより、入力がどこから来るのか (コンテキストを見て明白ではない場合)、どのような形式が期待されるのか、およびどこで検証されるのか (同じく明白ではない場合) を言及すると便利です。</p>
  <h2>2. 信頼できるすべてのデータ ストアを判定する</h2>
  <p>&nbsp;各アプリケーションには、少なくとも 1 つ (通常は複数) のデータ ストアがあります。&nbsp; データ ストアが信頼できるかどうかを判断することは重要です。&nbsp; この場合のガイドラインは単純です。 対象のシステムがデータ ストアへの唯一の入力である場合、入力検証ルーチンによって施行されるセマンティクスに依存し、ストア内で見つかったすべてのデータに適用することが可能です。&nbsp; 他のアプリケーションがデータ ストアにアクセスする場合、これを行うことはできません。&nbsp; データ ストアにアクセスする他の全システムで各検証のセマンティクスをチェックすることは可能ですが、データ ストアを信頼できないものとして仮定し、悪意のあるデータの潜在的なソースとして扱い、他の入力と同じようにこのデータ ストアからの入力をすべて検証した方が簡単かつ安全です。</p>
  <h2>3. すべてのクロスオーバー ポイントを判定する</h2>
  <p>クロスオーバー ポイントは、悪意のある入力がバグになる場所の 1 つです。&nbsp; 必ずしも出力が発生する場所ではなく、 実際には、大規模なアプリケーションよりも多くのレイヤーでさらに発生することがよくあります。&nbsp; クロスオーバー ポイントは、コマンド テキストのより大きな本文にテキストとしてユーザー入力が含まれる場所、またはそれに基づいてセキュリティ関連の決定が行われる場所です。&nbsp; クロスオーバー ポイントの例として、動的 SQL クエリが挙げられます。&nbsp; この場合のリスクは、関連付けられているコマンド データにユーザー入力がクロスオーバーし、攻撃者によるコマンドの実行を許可してしまうことです。&nbsp; 別の例としては、XPath およびその他の XML インジェクションが挙げられます。&nbsp; この場合の最悪の状況は、言語の組み込みの "eval" コマンドや類似のコマンドによってユーザー入力が評価されてしまうことです。値が安全に見える場合でも、関連付けられているリスクを回避するために、これらのコマンドは一切使用してはなりません。</p>
  <p>クロスオーバー ポイントが見つかったら、すべての入力をトレース バックして事前に適切に検証されていることを確認し、形式、ソース、および検証ポイントを再度示すコメントを記述してください。&nbsp;&nbsp;クロスオーバー ポイントの持つ安全な文字のセットは、関連するテクノロジによって異なります。&nbsp; 下に説明されているホワイトリスト アプローチを使用し、このクロスオーバー ポイントに対する安全な文字のセットを、検証ツールによって許可されるものと比較してください。 許可される文字は、安全な文字のサブセットでなければなりません。</p>
  <p>可能な場合は、クロスオーバー ポイントをすべて削除する手順を実行してください。&nbsp; 動的 SQL からバインド パラメータ付きのストアド プロシージャに切り替えると、クロスオーバー ポイントのカテゴリ全体がシステムから削除され、攻撃のクラス全体に対するリスクが大幅に減少します。&nbsp; 他のタイプのクロスオーバーでも類似のことを実行できます。</p>
  <h2>4. すべての出力を判定する</h2>
  <p>考慮する最後の事項は、システムからの出力のリストです。&nbsp; これは、クロスオーバー ポイントのリストと特定の部分が重なりますが、問題ありません。&nbsp; この場合も、各出力に対して許可される形式を判定し、受信データが検証される場所を検査する必要があります。&nbsp; 危険が文字がデータに含まれている可能性があるかどうかという問題が存在する場合は、特定の出力に適切な方法でエンコーディングしてください。&nbsp; 予想以上に多くの出力コンテキストが存在し、 HTML 属性のコンテンツ、タグ自体、タグ間のフリー テキスト、および JavaScript 文字列が持つ安全な文字のセット (および JavaScript 文字列の場合は異なるエンコーディングも) は、それぞれ異なっています。&nbsp; 入力ソース、形式、検証ポイント、およびエンコーディング ポイントに関するコメントも役立ちます。</p>
  <h2>5. 集中化された検証モジュールを構築する</h2>
  <p>入力検証の実装における最大の危険の 1 つは、一貫性のない検証です。 つまり、あるデータ パスでは攻撃がキャッチされても、別のデータ パスではキャッチされないという状況を意味します。&nbsp; ただし、攻撃者はそれらすべてで攻撃を試みます。&nbsp; この問題を解決する方法は、入力検証に対して責任のある単一ポイントを持つことです。&nbsp; この場所については、設計により異なります。&nbsp; 入力の各部分がオブジェクトである場合は、そのオブジェクトの入力に対する検証をオブジェクト コンストラクタおよびセッタに実行させると適切な可能性があります。&nbsp; それほど厳密ではない OO システムでは、異なる各入力形式に対してメソッドを持つ単一モジュールの方がより適していることがあります。</p>
  <p>選択するメソッドにかかわらず、特定のデータ型に対する入力検証ルーチンはできるだけ厳密でなければなりません。&nbsp; たとえば、米国の郵便番号を検証する場合は 5 桁または 9 桁のみを許可し、それ以外は許可してはなりません。&nbsp; 国際郵便番号の場合は、文字も許可するより緩やかな形式を使用して別途に検証するか、または各国の郵便番号を理解するより複雑な検証ツールを構築してください (高レベルの完全性を確保する必要がある場合)。</p>
  <h2>6. 集中化されたエンコーディング モジュールを構築する</h2>
  <p>出力を作成するために使用されるのと同じライブラリを介してすべてのエンコーディング ルーチンが実行されるのが理想的です。&nbsp; これについては多くの HTML 制御ライブラリが実行を試みますが、ホワイトリスト アプローチを使用しようとするライブラリは存在しません。&nbsp; 代わりに、害を及ぼす可能性のある文字 (断定的に不完全なリスト) を推測しようとします。&nbsp; 新しい出力ライブラリを構築しようとしない限り (十分な大きさのアプリケーションではオプションの場合がある)、持っている各出力コンテキストに対してデータ エンコーダのセットを構築すべきです。&nbsp; これらのエンコーダは、出力の実際のポイントにできるだけ近い場所で使用する必要があります。 すると、代替データ パスがエンコーディングをスキップする可能性が最小限に抑えられ、どんなコンテキストで出力が使用されるのかを開発者は具体的に知ることができます。&nbsp; エンコーディングされたデータを格納するという誘惑は避けてください。その理由は、エンコードしたコンテキストでのみ使用するのが当初の目的であったとしても、後にこれが変化する可能性があるためです。</p>
  <h2>7. システム全体ですべてのパスが検証を保持するようにする</h2>
  <p>検証システムが完了したら、システム全体でデータが通るすべてのパスをチェックし、期待の検証プロパティを保持することを確認してください。&nbsp; タンパリングされていないことを確実にするために暗号化署名が使用されないかぎり、クライアントまたは別のシステムを通じてラウンドトリップで送信される入力は再検証されなければなりません。&nbsp; 信頼されていないシステムで行われる検証も繰り返される必要があります。&nbsp; JavaScript におけるクライアント側検証は気の利いた UI ではありますが、簡単に回避されてしまうセキュリティ対策です。</p>
  <h1>問題の例</h1>
  <p>e コマース サイトの Web アプリケーション一式は、共通のバックエンド データベースを共有します。&nbsp; 最大のアプリケーションは、注文入力システムとショッピング カートです。&nbsp; これが最初に構築されたアプリケーションであり、データベースが信頼できるという仮定の下に設計されました。&nbsp; 後に、ユーザーが在庫レベルをすばやくチェックすることを可能にする簡易アプリが構築されました。&nbsp; データベースの使用はわずかな「読み取り専用」であったため、入力検証がアプリケーションに組み込まれませんでした。&nbsp; アプリケーションには SQL インジェクションが含まれていて、ショッピング カート アプリケーションを表示するページに JavaScript をインジェクトしてユーザーのパスワードを盗めるようにデータベースを変更することを攻撃者に対して可能にしていました。&nbsp;</p>
  <h1>ソリューションの例</h1>
  <p>e コマース サイトの Web アプリケーション一式は、共通のバックエンド データベースを共有します。&nbsp; 最大のアプリケーションは、注文入力システムとショッピング カートです。&nbsp; これが最初に構築されたアプリケーションであり、データベースが信頼できるという仮定の下に設計されました。&nbsp; 後に、ユーザーが在庫レベルをすばやくチェックすることを可能にする簡易アプリが構築されました。&nbsp;&nbsp;新しいアプリケーションが追加された際に、信頼できるデータ ストアとしてデータベースが扱われていないことに開発者が気付き、データベースからの入力においてデータ検証を実行するためにメイン アプリケーションにコードが追加されました。&nbsp;&nbsp;&nbsp;新しいアプリケーションでのデータベースの使用はわずかな「読み取り専用」であったため、記述されている入力検証ルーチンが適切にチェックされませんでした。&nbsp; 新しいアプリケーションを介した SQL インジェクションが攻撃者によって検出され、バックエンド データベースが変更されましたが、その攻撃をメイン アプリケーションまでチェーン スルーさせることはできませんでした。&nbsp; さらに、メイン アプリケーションのデータ検証ルーチンによって実行されたログ記録は、問題に対するオペレーション グループを変更し、より小規模なアプリケーションの修正を可能にしました。</p>
  <h1>その他のリソース</h1>
  <ul>
    <li>詳細については、「Chapter 4 - Design Guidelines for Secure Web Applications (第 4 章 - セキュリティ保護された Web アプリケーションの設計ガイドライン)」を参照してください。<a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li>
  </ul>
  <hr />
  <p>出典: Microsoft patterns & practices guidance</p>]]></Data>
  </Content>
</TeamMentor_Article>