<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1699223181" Content_Hash="-905180868">
  <Metadata>
    <Id>3aed3ac0-512b-4237-aa27-7e1271ed8aa0</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>クライアント入力に基づくセキュリティに関する意思決定の禁止</Title>
    <Category>パラメータ操作</Category>
    <Phase>設計</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>クライアント入力を使用してセキュリティに関する意思決定を行わないでください。&nbsp; セキュリティに関する意思決定は、サーバが管理する情報のみに基づいて行われることを確認してください。 </p>
  <h1>理由</h1>
  <p>クライアントの入力は、フォーム変数やクエ文字列パラメータなどの直接入力から、Cookieや接続情報などの非直接的な入力まで様々な形態をとります。&nbsp; これらは全く信用できず、&nbsp;クライアントからの情報は、ファット クライアントの場合ですら攻撃者により完全に制御されている場合があります。</p>
  <p>この情報のみに直接基づいてセキュリティ決定を行うと、攻撃者はそれら決定の結果を改ざんできます。&nbsp; たとえば、ファット クライアントがユーザーのロールリストを送ると、ユーザーはリストを変更できます。&nbsp; 役割キャッシュ用Cookieがもう一つの例として挙げられます。 Cookieが署名や暗号化により耐タンパーでない限り、ユーザーはシステム内のロールを自由に変更することができます。 </p>
  <h1>状況</h1>
  <p>セキュリティに関する意思決定は、アプリケーション タイプ、入力タイプまたはユーザー グループにかかわらず、クライアント入力に基づいて行うべきではありません。&nbsp; これにはクライアントの制御下にあり、改ざん包装されていない Cookie の内容をもとにした<b>Request.ServerName</b>といったようなものをもとにセキュリティに関する判断をすることが含まれます。&nbsp; </p>
  <p>本規則の唯一の例外は、パスワードの使用です。&nbsp; クライアントから送信されるパスワードは技術的にはクライアント入力ですが、これはさらなるセキュリティに関する意思決定を行うためではなく、認証チェックを行うためだけに使用されます。</p>
  <h1>対策</h1>
  <p>セキュリティ決定をクライアントデータによらないことを確実にするのは困難です。&nbsp; これらのステップでプロセスを実施することができます。 </p>
  <ol>
    <li>
      <p>誰かにロールをあてる場合、またはアクションを実行するべきと判断するといったようなセキュリティ判断点を全て特定します。&nbsp; このエレメントを知っておくことはアプリケーションのセキュリティに重要であるため、徹底して行います。&nbsp; この側面から、脅威モデルなどの完全性検査を含めた設計レビューの実施は第一歩としては良いですが、実際の実装を見直し、設計どおりの適切な動作を確認することも必要になります。</p>
      <li>
        <p>決定に使用されるデータを、それらがクライアントの入力に基づくものではないと確証できるまで追跡します。</p>
        <li>
          <p>データがクライアントを通して往復する場合、それがクライアントによって変更されることがないことを証明します（すなわちデータ&nbsp;が暗号文で署名されているということ）。</p>
          <li>
            <p>ロール編集コンポーネントなどクライアントの入力によってセキュリティ決定を行う場所があれば、それら例外をドキュメントし、コードパス監査の際に特に注意を払ってください。&nbsp; 例外は、意図されている業務ルールに従って機能することを確認します。&nbsp; セキュリティに影響を及ぼすすべての入力を注意して扱い、使用する直前に要求し、キャッシュを行わず、使用前に有効化するようにします。 また ViewStateUserKeys を使ってフォームを保護し、データはクエリ文字列には入れず、そしてデータを一般的にその他の機密情報と同じように扱います。&nbsp;&nbsp;</p>
          </li>
        </li>
      </li>
    </li>
  </ol>
  <h1>問題の例</h1>
  <p>ウェブベースのコンテンツ 管理システムには、一般ユーザー向けと管理者向けの2つのモードがあります。&nbsp; システムはCookieを使用してユーザーのロールを判別します。&nbsp; Cookieは符号なしのプレーン テキストです。&nbsp; 攻撃者がこれを見つけると、Cookieを彼らのマシン上で改ざんし、管理者になりすまします。</p>
  <p>同じシステムは <strong>Request.ServerName</strong> フィールドでユーザーがシステムの内部または外部とやり取りしているかを確認し、内部のユーザーには自動的に管理者の権限が与えられます。&nbsp; HTTP 1.1 ヘッダを偽造して、要求に対してシステムの内部に通信しているように見せかけ、攻撃者は認可コードを騙して管理特権を取得する恐れがあります。</p>
  <p />
  <h1>ソリューションの例</h1>
  <p>ウェブベースのコンテンツ 管理システムには、一般ユーザー向けと管理者向けの2つのモードがあります。&nbsp; システムは、ユーザーが有するロールセットを、攻撃者が変更できないように、サーバ側のセッション変数で保存します。&nbsp; 要求がどこから来るかに関わらず、システムに使用するすべてのインターフェイスは同じ認可コードを使用します。&nbsp; さらに、ウェブサーバの名前が必要であれば、要求オブジェクトではなく、設定変数から取得します。</p>
  <p />
  <hr />
  <p>出典: Microsoft patterns & practices guidance </p>]]></Data>
  </Content>
</TeamMentor_Article>