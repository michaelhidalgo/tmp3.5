<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-2080995311" Content_Hash="-609479892">
  <Metadata>
    <Id>8a220644-4285-423d-9ebc-7f9069a038a5</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>全てのソースからの入力を型、長さ､形式および範囲について検証する</Title>
    <Category>入力とデータの検証</Category>
    <Phase>実装</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>行うべき事柄</h1>
  <p>入力を信頼してはいけません。&nbsp; 予期した入力と合致するものをサーバで認め、どのコンテキストで使用されるのかに注意を払い、出力時に適切にエンコードします。 </p>
  <h1>理由</h1>
  <p>悪意のある入力を渡す攻撃者は、アプリケーションの脆弱性を悪用する目的で、SQL インジェクション、クロスサイト スクリプティング、およびその他のインジェクション攻撃を行うおそれがあります。&nbsp; 入力の検証は、受信した入力と期待フォーマットとの一致を保証することによって、これらのリスクを軽減します。&nbsp;入力検証だけでは十分ではありません。 出力エンコーディングは、これらの攻撃を防ぐために必要ですが、セキュリティと信頼性のためにも重要な手順です。 </p>
  <h1>状況</h1>
  <p>すべての入力は、そのソースに関わらず、検証される必要があります。&nbsp; 静的であるはずのデータベースにあるデータでも、データがローカル コードベースの対象範囲内で静的でない限り、悪意のあるユーザーにより編集可能です。&nbsp; </p>
  <h1>対策</h1>
  <ol>
    <li>
      <p>
        <strong>データを検証する箇所。</strong> 入力は、サーバ側でセキュリティ チェックについて検証される必要があります。&nbsp; ユーザー エクスペリエンスの観点から、特にラウンドトリップの待ち時間が長いウェブ アプリケーションなどでは、クライアント側で入力をチェックするのは便利ですが、このClient-side Validationは、攻撃者によって回避されるため、セキュリティ上の保証を提供するには不十分です。 </p>
      <li>
        <p>
          <strong>データを検証する対象。</strong> 既知の有効なデータをチェックして、型、長さ、形式、および範囲を検証することによって入力を制限します。&nbsp; サーバ コントロールから入力を取得するウェブ フォーム アプリケーションの場合は、RegularExpressionValidator、RangeValidator、および CustomValidator などの ASP.NET 検証コントロールを使用して、入力を検証および制限してください。&nbsp; システムの管理下にない入力はすべて検証するべきですが、ユーザーから直接送られてくる入力は必ず検証して、細心の注意を払う必要があります。&nbsp; </p>
        <li>
          <p>
            <strong>検証を実装する方法。</strong> 多くのウェブ アプリケーションは、HTML コントロール、サーバ コントロール、クエリ文字列、およびCookieなどのさまざまなソースからの入力を受け入れます。&nbsp; インジェクション攻撃を防ぐために、これらすべてのソースからの入力を検証します。&nbsp; 入力を検証するには正規表現を使用します。&nbsp; 以下の例は、正規表現 (Regex) クラスの使い方を示しています。 </p>
 <pre>System.Text.RegularExpressions の使用<br />// Instance method:Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");<br />Response.Write(reg.IsMatch(Request.QueryString["Name"]));<br />// Static method:<br />if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$"))<br />{<br />   // Name does not match expression<br />}</pre>
          <p>正規表現を定型としてキャッシュできない場合は、不要なオブジェクトの作成を避けるため、パフォーマンスに関する理由から、できる限り、静的な IsMatch メソッドを使用するようにしてください。 </p>
          <p>一般には、該当フィールドで想定されるすべての入力を受け入れる、最も許容度の低い表現で入力を検証します。&nbsp; フィールドに特定の内部構造体がある場合は、それをチェックします。&nbsp; ユーザーがデータを入力する可能性のある標準的な形式の範囲があり、その形式を簡単に 1 つの内部形式に変換できる場合は、そのようにしてください。&nbsp; </p>
          <p>
            <strong>注記:</strong>&nbsp;&nbsp;&nbsp; 入力の検証は、出力のフォーマット、クエリのパラメータ、およびその他の形でユーザー入力を慎重に扱う必要性をなくすわけではありません。 </p>
          <li>
            <p>
              <strong>特定のデータ型の検証。</strong> 特定のデータ型は、様々なタイプのチェックを許容し必要とします。&nbsp; 以下は一般的な データ型についてのガイドラインです:</p>
            <ul>
              <li>
                <p>
                  <strong>数字データ。</strong> すべての数値フィールドで型と範囲をチェックします。 サーバ制御を使用していない場合､正規表現および Regex クラスを使用し、入力値を整数または倍精度に変換して変換が有効であったことを確認し、次に範囲チェックを実施することによって数字の範囲を検証できます。&nbsp; クレジット カード番号などの内部チェックサムがある場合は、それもチェックします。</p>
                <li>
                  <p>
                    <strong>アドレス データ。</strong> 住所データは、情報量がかなり豊富な内部構造体です。 検証ルーチンがこの構造体を理解すればするほど、情報をより厳密に検証することができます。&nbsp; 電話番号は 10 桁の文字列、または国際番号が許容される場合は「+」で始まる可変桁数の文字列として検証できます。&nbsp; 必要であれば、国コードを判別し、厳密な番号形式を調べることができます。&nbsp; 電話番号は複数の違った方法で書かれるものの、検証前にすべての非数字文字を取り除くことで正準表現を作成できます。サイトにデータを入力する際の、ユーザーの時間といらだちを減らすことができます。&nbsp; 番地については、もう少し注意が必要です。 入力が、番地、市区町村などに分けられる場合、各フィールドは安全な文字セットを別々に定義して持つことができます。たとえば、市区町村名には番号は必要ありません。&nbsp; 名前については非常に単純ですが、”” 文字が有効な入力であるケースの 1 つです。したがって、すべての入力と同様に、データベース レベルで適切に処理される必要があります。&nbsp; また、現在のコードページによっては、名前と住所でアクセント付き文字を許容する必要があることに注意してください。</p>
                  <li>
                    <p>
                      <strong>参照データ。 </strong>他のものを参照するデータは、検証の最終的な 1 ステップ、つまり参照対象の確認を経て参照の有効性を保証できます。&nbsp; たとえば、郵便番号は、正準リストで正しいことを検証し、郵便番号とのクロスチェックで番地も検証できます。&nbsp; ある発注管理システムでは、品目 ID は有効な ID のリストに対してチェックされます。</p>
                  </li>
                </li>
              </li>
            </ul>
          </li>
        </li>
      </li>
    </li>
  </ol>
  <h1>問題の例</h1>
  <p>ウェブストアの注文フォームには、名前、住所、電話番号、商品番号、数量を入力するいくつかの欄があります。&nbsp; 各項目はデータ検証されることなく単純にデータベースに追加され、データベースによる型変換が実施されます。&nbsp; データベース内の型変換は、SQL インジェクションを防ぐことなく、範囲外のデータにはほとんど効果がありません。&nbsp; 攻撃者は、データベースに不要なデータを入れるような小さなものから、SQL インジェクションやクロスサイト スクリプティングなどの破壊的なものまで、数々の攻撃を行う恐れがあります。</p>
  <h1>ソリューションの例</h1>
  <p>ASP.NET アプリケーションはウェブストアの注文を含みます。&nbsp; すべてのフォーム フィールドが検証され、収集されるデータについての保証がより確実になります。&nbsp; 電話番号は、10 桁 (数字以外の文字をすべて削除した後) の文字列、または国際番号が許容される場合には、「+」で始まる可変桁数として検証されます。&nbsp; </p>
  <p>名前、住所、および商品番号の検証は、もう少し複雑になります。&nbsp; まず、それぞれのケースについて有効な文字セットが使用されているかどうかを判別します。&nbsp; 名前については、スペース、大文字、小文字(コードページのアクセント書式を含む)、数字、句読点があれば十分です。&nbsp; 住所には、最低でも、コンマ、ハイフン、番号記号を追加する必要があります。&nbsp; 商品番号の検証は単純で、整数にキャストして、結果が正しい範囲内にあることをチェックします。または、文字列内に内部書式設定があるかどうかをチェックする、より複雑な正規表現を使用する場合もあります。 </p>
  <p>最後のオプションのデータ検証手順は、データが有効な物を参照していることの確認です。&nbsp; データは、特に、この後のチェックでデータベース クエリが必要になる場合に、まず形式について検証されなければなりません。&nbsp; 商品番号については、言うまでもなく、DB 内に存在するかどうかをチェックします。新しい注文を作成するストアド プロシージャの一部として通常行われますが、名前、住所、電話番号を同様に複数回チェックします。&nbsp; たとえば、住所フィールドが複数の部分に分かれている場合は、最低でも、都道府県情報、郵便番号、市区町村名を、既存のリストを使用して検証します。</p>
  <hr />
  <p>出典: Microsoft patterns & practices guidance </p>]]></Data>
  </Content>
</TeamMentor_Article>