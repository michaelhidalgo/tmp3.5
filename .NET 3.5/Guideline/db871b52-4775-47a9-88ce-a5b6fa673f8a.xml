<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="1148449243" Content_Hash="851531180">
  <Metadata>
    <Id>db871b52-4775-47a9-88ce-a5b6fa673f8a</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>入力検証を集中させる</Title>
    <Category>入力とデータの検証</Category>
    <Phase>設計</Phase>
    <Technology>Web アプリケーション</Technology>
    <Type>ガイドライン</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>適用対象</h1>
  <ul>
    <li>Web アプリケーション</li>
  </ul>
  <h1>行うべき事柄</h1>
  <p>すべての Web アプリケーションにより入力が検証されなければならず、これについては単一の集中化された場所にて実行して一貫性を確保する必要があります。</p>
  <h1>理由</h1>
  <p>入力検証にて一貫性のないアプリケーションは、攻撃を適切に防止することができません。&nbsp; また、集中化により、データ形式が変更されると検証標準も一貫して変更されるようになります。&nbsp; さらに集中化は、開発作業を軽減し、将来的なメンテナンスにも役立ちます。</p>
  <h1>状況</h1>
  <p>すべてのシステムによって入力検証が集中化される必要があります。</p>
  <h1>対策</h1>
  <p>入力検証を正しく行うためには注意が必要で、 Web アプリケーションにとってこれがセキュリティ上の最大の問題であるのには理由があります。&nbsp; ただし、体系的なアプローチを使用すれば、この問題の解決はそれほど困難ではありません。&nbsp; 以下の手順を実行します。</p>
  <ol>
    <li>
      <strong>すべての入力を判定する:</strong> システムに対するすべての入力およびそれらが持つ形式を識別してください。 <li><strong>信頼できるすべてのデータ ストアを判定する:</strong> データの有効性を保持するために信頼できるデータの取得元となるすべての場所と、出力の検証が必要な人を識別してください。<li><strong>すべてのクロスオーバー ポイントを判定する:</strong> 入力によってその他のデータが悪影響を受ける可能性があるポイントをすべて検出し、これらのポイントの前に検証が実行されるようにしてください。 <li><strong>すべての出力を判定する:</strong> システムからの出力をすべて検出し、コンテキストに適切なエンコーディングがそれらのポイントで実行されるようにしてください。 <li><strong>検証を集中化する:</strong> すべての検証コードを単一のモジュールに集中化し、常にこれが適切に使用されるようにしてください。 <li><strong>エンコーディングを集中化する:</strong>&nbsp; すべてのエンコーディング コードを単一のモジュールに集中化し、これによってすべてのコンテキストが処理され、常にこれが適切に使用されるようにしてください。 <li><strong>すべてのパスが検証を保持するようにする:</strong> システム全体で各パスがデータを有効な形式で保持するようにし、 クライアントまたはクライアント側検証を通じたラウンド トリップを監視してください。</li></li></li></li></li></li></li>
  </ol>
  <p>入力検証の実装における最大の危険の 1 つは、一貫性のない検証です。 つまり、あるデータ パスでは攻撃がキャッチされても、別のデータ パスではキャッチされないという状況を意味します。&nbsp; ただし、攻撃者はそれらすべてで攻撃を試みます。&nbsp; この問題を解決する方法は、入力検証に対して責任のある単一ポイントを持つことです。&nbsp; この場所については、設計により異なります。&nbsp; 入力の各部分がオブジェクトである場合は、そのオブジェクトの入力に対する検証をオブジェクト コンストラクタおよびセッタに実行させると適切な可能性があります。&nbsp; それほど厳密ではない OO システムでは、異なる各入力形式に対してメソッドを持つ単一モジュールの方がより適していることがあります。</p>
  <p>選択するメソッドにかかわらず、特定のデータ型に対する入力検証ルーチンはできるだけ厳密でなければなりません。&nbsp; たとえば、米国の郵便番号を検証する場合は 5 桁または 9 桁のみを許可し、それ以外は許可してはなりません。&nbsp; 国際郵便番号の場合は、文字も許可するより緩やかな形式を使用して別途に検証するか、または各国の郵便番号を理解するより複雑な検証ツールを構築してください (高レベルの完全性を確保する必要がある場合)。</p>
  <h1>その他のリソース</h1>
  <ul>
    <li>詳細については、「Chapter 4 - Design Guidelines for Secure Web Applications (第 4 章 - セキュリティ保護された Web アプリケーションの設計ガイドライン)」(<a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a>) を参照してください。 </li>
  </ul>
  <hr />
  <p>出典: Microsoft patterns & practices guidance</p>]]></Data>
  </Content>
</TeamMentor_Article>