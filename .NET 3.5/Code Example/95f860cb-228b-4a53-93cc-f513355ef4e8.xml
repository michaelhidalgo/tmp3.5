<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="-306380758" Content_Hash="1586516712">
  <Metadata>
    <Id>95f860cb-228b-4a53-93cc-f513355ef4e8</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>暗号化された署名 Cookie の復号と検証</Title>
    <Category>Cookie</Category>
    <Phase>実装</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>コード例</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>適用対象</h1>
  <ul>
    <li>C# </li>
  </ul>
  <h1>概要</h1>
  <p>このコード スニペットの目的は、信頼済みアプリケーションによって設定された、暗号化されたアプリケーション Cookieを復号化して検証する方法を示すことです。 このコード例では、暗号化された BLOB に含まれるメッセージの完全性と新鮮さ (たとえば、タイムスタンプ) を検証します。 このコード サンプルは、共通のサーバ側セッション状態がないときに使用することができます。</p>
  <h1>目的</h1>
  <ul>
    <li>セッション再生を軽減するコントロールを提供する<li>HMAC メッセージ署名により、ビジネス ロジック、認証または認可コンテキスト、あるいは全体的なデータの完全性に影響を与えうる、 Cookie パラメーターをタンパリングするユーザーの能力から保護する<li>メッセージの完全性を検証してメッセージ タンパリングを検出するコントロールを提供する<li>データ保護 API (DPAPI) を使用して、共有秘密暗号鍵および HMAC 署名鍵の安全な格納場所を確保する</li></li></li></li>
  </ul>
  <h1>ソリューションの例</h1>
  <p>
    <strong>鍵の取得と保存のための DPAPI ユーティリティ クラス: </strong>
  </p>
 <pre>public class DPAPIUtil<br />{<br />    private string registryKeyName = "ACMEWebApplication";<br />    private string registryEncValueName = "symmetrickey";<br />    private string registryHMACValueName = "hmackey";<br />    string fullRegistryKeyPath = "";<br />    public DPAPIUtil()<br />    {<br />           fullRegistryKeyPath = @"HKEY_CURRENT_USER\" + registryKeyName;<br />    }<br />    public void StoreHMACKey(byte[] val)<br />    {<br />        // Encrypt the HMAC signing key using the DPAPI ProtectedData class.<br />        //<br />        // We're using the CurrentUser scope instead of the MachineKey scope<br />        // so that other, potentially malicious applications cannot access<br />        // this key in the registry and decrypt.<br />        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />            DataProtectionScope.CurrentUser);<br />        // Create a security context for a new key that we will use to store our encrypted connection string.<br />        // The security context will restrict access to only our user.<br />        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />        RegistrySecurity security = new RegistrySecurity();<br />        RegistryAccessRule rule = new RegistryAccessRule(user,<br />                        RegistryRights.FullControl,<br />                        InheritanceFlags.ContainerInherit,<br />                        PropagationFlags.None,<br />                        AccessControlType.Allow);<br />        security.AddAccessRule(rule);<br />        // Actually create the new registry key and apply the security context we just came up with.<br />        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br />        // Write the encrypted string into the registry<br />        Registry.SetValue(fullRegistryKeyPath, registryHMACValueName, encryptedValBytes);<br />    }<br />    public void StoreSymmKey(byte[] val)<br />    {<br />        // Encrypt the shared secret key using the DPAPI ProtectedData class.<br />        // <br />        // We're using the CurrentUser scope instead of the MachineKey scope<br />        // so that other, potentially malicious applications cannot access<br />        // this key in the registry and decrypt.<br />        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />            DataProtectionScope.CurrentUser);<br />        // Create a security context for a new key that we will use to store our shared secret key.<br />        // The security context will restrict access to only our user.<br />        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />        RegistrySecurity security = new RegistrySecurity();<br />        RegistryAccessRule rule = new RegistryAccessRule(user,<br />                        RegistryRights.FullControl,<br />                        InheritanceFlags.ContainerInherit,<br />                        PropagationFlags.None,<br />                        AccessControlType.Allow);<br />        security.AddAccessRule(rule);<br />        // Actually create the new registry key and apply the security context we just came up with.<br />        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br />        // Write the encrypted string into the registry<br />        Registry.SetValue(fullRegistryKeyPath, registryEncValueName, encryptedValBytes);<br />    }<br />    public byte[] RetrieveHMACKey()<br />    {<br />        // Read the encrypted hmac signing key value from the registry<br />         byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryHMACValueName, null) as byte[];<br />         // Decrypt the encrypted bytes using DPAPI and return<br />            byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes,<br />                null,<br />                DataProtectionScope.CurrentUser);<br />         return decryptedValBytes;<br />     }<br />    public byte[] RetrieveSymmKey()<br />    {<br />        // Read the encrypted symmetric key value from the registry<br />         byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryEncValueName, null) as byte[];<br />        // Decrypt the encrypted bytes using DPAPI and return<br />        byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes,<br />            null,<br />            DataProtectionScope.CurrentUser);<br />        return decryptedValBytes;<br />    }<br />}</pre>
  <p>
    <strong> Cookie内の暗号化および署名された鍵の復号化と検証</strong>
  </p>
  <p>Cookie値の取得:</p>
 <pre>        bool isValidHMAC = false;<br />        bool isValidTS = false;<br />        // Read our encrypted cookie value<br />        byte[] encvalWithIV = Convert.FromBase64String(Request.Cookies["CookieJar"].Value);<br />        byte[] iv = new byte[16];<br />  // We're expecting a 16 byte IV<br />        byte[] encval = new byte[encvalWithIV.Length - 16];<br /> // Byte array for our message without IV<br />        // Parse the IV from the first 16 bytes of the cookie<br />        Array.Copy(encvalWithIV, iv, iv.Length);<br /><br />        Array.Copy(encvalWithIV, 16, encval, 0, encval.Length);<br />        // We'll retrieve our symmetric encryption key from the registry<br />        DPAPIUtil dputil = new DPAPIUtil();<br />        byte[] enckey = dputil.RetrieveSymmKey();<br />        // Preparation to decrypt our cookie value:<br />        // <br />            // Create the Crypto provider<br />        Rijndael rij = Rijndael.Create();<br />        // Load the DPAPI protected key<br />        rij.Key = enckey;<br />        rij.IV = iv;<br />        MemoryStream ms = new MemoryStream();<br />        // Instantiate our decryptor stream to which we write our encrypted value, our<br />        // memory stream will contain the decrypted value to be used by our application<br />        CryptoStream dcs = new CryptoStream(ms, rij.CreateDecryptor(), CryptoStreamMode.Write);<br />        // Write the decrypted value to the cryptostream<br />        dcs.Write(encval, 0, encval.Length);<br />        dcs.Close();<br />        string decryptedCookie = UnicodeEncoding.ASCII.GetString(ms.ToArray());<br />        // Now we need to validate the HMAC to ensure the message wasn't altered<br />        // We use a distinctly seperate HMAC key to ensure that if the encryption key<br />        // is compromised message integrity may still be guaranteed and protects us against<br />        // parameter tampering.<br />        HMACSHA256 hmac = new HMACSHA256();<br />        // Retrieve the HMAC key from the encrypted registry value using our DPAPI helper<br />        hmac.Key = dputil.RetrieveHMACKey();<br />        // We store the HMAC in the last 32 bytes of the message<br />        byte[] hmacValue = new byte[32];<br />        Array.Copy(ms.ToArray(), ms.ToArray().Length - 32, hmacValue, 0, hmacValue.Length);<br />        // To validate the HMAC we'll recompute an HMAC using the HMAC key and compare this with<br />        // the HMAC sent to us by the remote application<br />        string msg = decryptedCookie.Substring(0, decryptedCookie.Length - 32);<br />        byte[] hmacValueNew = hmac.ComputeHash(UnicodeEncoding.ASCII.GetBytes(msg));<br />        if (Convert.ToBase64String(hmacValue) == Convert.ToBase64String(hmacValueNew))<br />        {<br />            isValidHMAC = true;<br />        }<br />        else<br />        {<br />            // Invalidate our session and throw an error<br />            Session.Abandon();<br />            throw new Exception("Invalid HMAC Detected");<br />        }<br />        lblHMACBool.Text = isValidHMAC.ToString();<br />        // Lastly validate the timestamp to ensure it is no more than 5 minutes old<br />        //<br />        // The timestamp is the last value stored in our message<br />        string ts = msg.Substring(msg.LastIndexOf("|") + 1);<br />        DateTime cookieTs = DateTime.FromBinary(long.Parse(ts));<br />        DateTime curTs = DateTime.Now;<br />        // Determine how old the cookie is that we're trying to validate.<br />        // In our example below we simply check to make sure the cookie isn't older than<br />        // 5 minutes; This technique doesn't elliminate session replay but does help to minimize<br />        // the window of opportunity in which an attacker may replay a session.<br />        //<br />        // In an ideal scenario it may be advantageous to use a sequence number which we<br />        // store in the database each time a cookie is used, so that it may not be used twice.<br />        TimeSpan tspan = new TimeSpan(curTs.Ticks - cookieTs.Ticks);<br />        // If the cookie is older the 5 minutes we'll require the user to obtain a new cookie<br />        if (tspan.Minutes &gt; 5)<br />        {<br />            // Redirect to our source site<br />            Response.Redirect("/CookieExample/SetCookie.aspx");<br />        }<br />        else <br />        {<br />            isValidTS = true;<br />            //Parse the cookie and consume its values after performing data validation<br />        }<br />        lblTSBool.Text = isValidTS.ToString();<br /></pre>
  <h1>問題の例</h1>
  <p>以下の例は、暗号化と鍵署名が使用されていない 2 つのウェブ アプリケーション間でメカニズムを共有する、レベルの低い設計のCookieを示しています。</p>
  <p>Cookie値を設定します。</p>
 <pre>        cookieval = user + "|" + uid + "|" + adminRole.ToString();<br />        HttpCookie chocolateChip = new HttpCookie("CookieJar", cookieval);<br />        // Ensure that proper secure cookie modes are set:<br />        //<br />        // Make cookies unavailable to client side scripts<br />        chocolateChip.HttpOnly = true;<br />        // Set the cookie transport mechanism to SSL only<br />        chocolateChip.Secure = true;<br />        // Ideally choose a more restrictive domain under which cookies are set<br />        chocolateChip.Domain = ".ourapp.microsoft.com";<br />        // Place some restrictions on which web paths can access our cookies<br />        chocolateChip.Path = "/CookieExample/";<br />        // Finally set the cookie<br />        Response.Cookies.Add(chocolateChip);</pre>
  <p>Cookie値を取得して使用します。</p>
 <pre>        cookieval = Request.Cookies["CookieJar"].Value;<br />        // Parse and consume the cookie value attributes<br />        ...</pre>
  <p>この例には問題があります。</p>
  <ul>
    <li>ユーザーに絶対に公開されるべきではないデータを含む可能性のある、機微情報が Cookie 内で公開される<li>Cookie はユーザー (中間者攻撃のシナリオの場合は中間者) によるタンパリングに対して脆弱である<li>Cookie はリプレイに対して脆弱である<li>Cookie が送信中に改ざんされる場合は、かかる状況を検出する方法はない<li>.ourapp.microsoft.com ドメイン内のウェブ アプリケーションはCookieにアクセスできます。</li></li></li></li></li>
  </ul>
  <p>上記のコードには示されていない、その他の一般的なコーディングの誤りにも注意する必要があります。</p>
  <ul>
    <li>弱い暗号鍵を使用した暗号化 (一般的&lt;128ではあるが、暗号化アルゴリズムに依存する)<li>証明されていない暗号化アルゴリズムまたは独自の暗号化アルゴリズムの使用<li>不適切な暗号の種類 (ブロック暗号ではなくストリーム暗号など) の使用<li>不適切な暗号化モード (チェーン ブロックの欠如) の使用<ul><li>暗号化を使用したとしても Cookie のタンパリングをより容易にする (ブロックの交換または再整理)<li>送信される共通値の情報漏えいをもたらす</li></li></ul><li>無作為の初期化ベクトル (IV) を選択していない<ul><li>送信される共通値の情報漏えいをもたらす</li></ul><li>HMAC を含めていない<ul><li>暗号化された値がさらに改ざんされ検出されない場合がある</li></ul><li>HMAC キーと暗号鍵は同等である<ul><li>1 つの鍵の漏えいはシステム全体の漏えいに繋がる</li></ul><li>タイムスタンプまたはセッション ID を含めていない<ul><li>暗号値が再生される場合がある</li></ul></li></li></li></li></li></li></li></li>
  </ul>
  <h1>テスト ケース</h1>
  <p>上記のサンプル コードを活用するプロジェクトには、以下のクラスをインクルードする必要があります。</p>
 <pre>        using System;<br />        using System.Collections.Generic;<br />        using System.Security.Cryptography;<br />        using System.Security.AccessControl;<br />        using System.Text;<br />        using Microsoft.Win32;</pre>
  <p>ソリューション コードを含むウェブ アプリケーションを参照すると、暗号化および署名されたCookie値が生成されます。 以下のCookie値が、安全なCookie オプションでサーバによって設定されます。</p>
 <pre>Set-Cookie:<br />CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCjaK5<br />aupWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88cx35<br />Jt9sQIQmjAgCmecj6VhHwKfbrZ;<br />domain=.ourapp.microsoft.com;<br />path=/CookieExample/; secure; HttpOnly</pre>
  <p>次のプロパティを含む Cookie 値を監視する</p>
 <pre>        Change with each encryption operation (due to random IV, and appended timestamp value)<br />        Base64 decoding the "CookieJar" value yields and encrypted array of bytes</pre>
  <h1>期待される結果</h1>
  <p>HTTP レスポンス ヘッダ:</p>
 <pre>Set-Cookie: CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCja<br />K5aupWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88<br />cx35Jt9sQIQmjAgCmecj6VhHwKfbrZ; domain=.ourapp.microsoft.com;<br /> path=/CookieExample/; secure; HttpOnly</pre>
  <h1>シナリオ</h1>
  <ul>
    <li>Web アプリケーションは、セッション状態内の何らかの詳細情報を別のアプリケーションに分配する必要がある (シングル サインオン、分散型 Web サーバ アーキテクチャーなど)<li>ウェブ アプリケーションは、共通のサーバ側データ ストアを通してセッション状態を共有することができないインフラストラクチャ内に展開される。 <li>共有対称鍵と HMAC 署名鍵は、帯域外であっても、他のセキュア通信チャネルを介してであっても、事前に確立される。 <li>開発者は、ビジネス ロジック、認証または認可コンテキストあるいは全体的なデータの完全性に影響を与える可能性のある、ユーザーによる Cookie パラメーターのタンパリングを回避することを望む<li>セッション状態を外部のアプリケーションに安全に分配する<li>Cookie の暗号化により機密性を提供する<li>暗号ブロブに組み込まれる HMAC コードを使用してメッセージの完全性を提供する<li>セッション タイムアウト メカニズムを使用してセッション リプレイを軽減する<li>ユーザーは、複数のウェブ サーバにわたって配布されたデータを取得する必要がある。各サーバは、カスタマー ポータル、レポート サーバなど、異なる目的で稼働している。</li></li></li></li></li></li></li></li></li>
  </ul>
  <h1>詳細情報</h1>
  <p>この実装は、マシン鍵ではなく、DPAPI ユーザー鍵を利用します。 これは、AES 共有秘密鍵および HMAC 署名鍵が、同じユーザー コンテキスト内で実行されているプログラムからのみアクセス可能で、異なるサービス アカウントの下で実行されている他のアプリケーションによってアクセスされないことを意味しています。 これにより、接続文字列データを不正に入手しようとする悪意のあるアプリケーション (ウイルスやトロイの木馬など) に対してさらなる保護が加えられますが、異なるアカウントで実行される複数のアプリケーション間での共有が必要な場所では問題になります。 他のプログラムが暗号化操作のために同じ鍵マテリアルにアクセスする必要がないときは、必ずこのアプローチを使用することをお勧めします。 メッセージ タンパリングを防ぐには、メッセージの暗号化のみでは不十分です。このため、HMAC (または共有秘密鍵に依存するメッセージ完全性チェック) を使用しています。 HMAC は別個の共有秘密鍵を使用して生成され、強力な一方向ハッシュ化アルゴリズムを使用して、与えられたメッセージのための一意のハッシュを生成します。 Cookie暗号化および署名を行っても、これらのCookieを傍受するユーザーは、メッセージのシーケンス番号を指定するメッセージ内に値が含まれていない場合を除いて、これらをサーバに対して再利用します。 対称共有鍵と HMAC 署名鍵は、これらの鍵を使用して暗号化されるデータの機密性を維持するために、安全に保存される必要があります。 この例では、暗号化された共有鍵ペアをレジストリ内に透過的に保存するために、DPAPI を使用しています。 AES と HMAC メッセージ署名の詳細は、この記事の対象範囲外です。 次のトピックについて、「追加のリソース」の記事で議論されています。</p>
  <ul>
    <li>ブロック暗号を通じて文字列を暗号化する (AES を使用)<li>メッセージ認証コードを生成する (HMAC)</li></li>
  </ul>
  <h1>その他のリソース</h1>
  <ul>
    <li>HTTP 要求 Cookie クラス: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemwebhttprequestclasscookiestopic.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemwebhttprequestclasscookiestopic.asp</a><li>HTTP Cookie: <a href="http://msdn.microsoft.com/library/en-us/wininet/wininet/http_cookies.asp">http://msdn.microsoft.com/library/en-us/wininet/wininet/http_cookies.asp</a><li>Cookie メンバー: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemnetcookiememberstopic.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemnetcookiememberstopic.asp</a><li>HMAC の定義: <a href="http://en.wikipedia.org/wiki/HMAC">http://en.wikipedia.org/wiki/HMAC</a><li>HMAC クラス: <a href="http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx">http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx</a></li></li></li></li></li>
  </ul>
  <hr />
  <p>出典: Microsoft patterns & practices guidance</p>]]></Data>
  </Content>
</TeamMentor_Article>