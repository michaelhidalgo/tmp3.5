<?xml version="1.0" encoding="utf-8"?>
<TeamMentor_Article Metadata_Hash="378667225" Content_Hash="-563042629">
  <Metadata>
    <Id>c392a633-2f74-4557-94ba-9fd6eeeefb95</Id>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>クライアント側検証攻撃</Title>
    <Category>入力とデータの検証</Category>
    <Phase>実装</Phase>
    <Technology> 任意</Technology>
    <Type>攻撃</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<br />
  <br />
  <h1>適用先</h1>
  <p>すべてのネットワーク アプリケーション</p>
  <h1>説明</h1>
  <p>攻撃者の観点からすると、&amp;#8212; 電子メール クライアントやブラウザーのようなネットワーク アプリケーションは、&amp;#8212; サーバーに送るネットワーク リクエストを生成する、単なるユーザー インターフェイスのように見えます。 クライアント アプリケーションは、リクエストを生成するために使用<strong>できる</strong>単なるツールで、攻撃者がこのツールを使用することは<strong>必要条件</strong>というわけではありません。 攻撃者は、クライアントが送信するネットワーク メッセージを監視して、同じリクエストを生成する別個のツールを書くことができます。 このシナリオでは、リクエストが実際のクライアント アプリケーションが生成したものか、それとも攻撃者のカスタム ツールが生成したものかを、サーバーが判断することは不可能です。</p>
  <p>そのため、サーバーに送信するデータに関してクライアントがどのような検証チェックを行っているとしても、新たに検証を行わない悪意のあるクライアント アプリケーションを書けば、簡単に回避することができます。 クライアント側の検証は、ユーザー体験と、アプリケーションの全体的なユーザビリティからすると、確かに重要です。 しかし、サーバー側でも、受信した入力がすべて有効であることを確認するため、同じチェックを行うことは重要です。</p>
  <h1>影響</h1>
  <ul>
    <li>ビジネス ルールに固有のアプリケーションのサブバージョン (例を参照してください)。 <li>SQL インジェクション、XML インジェクションおよび LDAP インジェクションのような、サーバー側でのコード インジェクション。 <li>バッファー オーバーフローまたは同様の状態を引き起こす、入力が原因での悪意のあるコードの実行。 <li>パス操作や正規化によって生じる情報漏えい。 <li>制約されていない、またはおかしな書式の入力が引き起こす DoS 攻撃。</li></li></li></li></li>
  </ul>
  <h1>脆弱性</h1>
  <ul>
    <li>サーバー上でユーザー入力を検証していない<li>クライアントの検証とサーバー側の検証に矛盾がある</li></li>
  </ul>
  <h1>対策</h1>
  <ul>
    <li>
      <strong>サーバー上で入力の制約を行います。</strong> クライアントが送る、すべてのユーザー入力に対して、強力なホワイトリスト スタイルのチェックを使用してください。<li><strong>サーバー側で入力を検証します</strong> 。証明されていない限り、入力は悪意のあるものだと仮定してください。 入力が検証を行うクライアントから来たものだとしても、サーバーで検証を行うまでは、入力を受け入れないでください。 クライアント側の検証はユーザビリティのためのものであるのに対し、 サーバー側の検証はセキュリティのためのものです。 <li><strong>入力検証でホワイトリストを使用します。</strong> 悪意のある入力は様々な形式で来ます。 既知の良い入力のインクルージョン リストを使用し、それ以外のものはすべて拒否することにより、できる限り多くのそのようなものに対して防御を行ってください。 </li></li></li>
  </ul>
  <h1>例</h1>
  <p>クライアントサイド検証攻撃の典型的な例は、E-コマースの Web サイトで生じます。 購入者が特定の品物の希望数を入力できる、標準のチェックアウト フォームを考えてみてください。 ページは、入力された値が正であることを検証する Javascript を含んでいる、このようなフォームを表示します。 サーバー側のコードは、Javascript の検証で十分であると仮定して、フィールドの検証を行わずに、このページから送信されたリクエストを処理します。 この正しくない仮定のため、攻撃者は、数量のフィールドに負の値を含む、カスタムの HTTP リクエストを生成することができます。 特定の条件下では、そのようなリクエストは、攻撃者の銀行口座の残高が増えるという結果を生じさせることがあります。</p>
  <h1>その他のリソース</h1>
  <ul>
    <li>
      <a href="http://www.owasp.org/index.php/Have_Your_Cake_and_Eat_It_Too">http://www.owasp.org/index.php/Have_Your_Cake_and_Eat_It_Too</a>
      <li>
        <a href="http://hudzilla.org/phpwiki/index.php?title=Validating_user_input">http://hudzilla.org/phpwiki/index.php?title=Validating_user_input</a>
        <li>
          <a href="http://php.robm.me.uk/">http://php.robm.me.uk/</a>
        </li>
      </li>
    </li>
  </ul>
  <h1>関連する項目</h1>
  <ul>
    <li>
      <a href="/article/ce899ba6-8ae2-4494-8706-ce863fae58e7">ガイドライン: ユーザーが指定したすべてのファイル名とパス入力をフィルター</a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>